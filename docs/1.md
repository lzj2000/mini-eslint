## 1. å‰è¨€

### ä¸ºä»€ä¹ˆè¦è‡ªå·±å®ç° ESLintï¼Ÿ

åœ¨ç°ä»£å‰ç«¯å¼€å‘ä¸­ï¼ŒESLint å·²ç»æˆä¸ºä¸å¯æˆ–ç¼ºçš„ä»£ç è´¨é‡ä¿éšœå·¥å…·ã€‚ä½†æ˜¯ï¼Œä½œä¸ºå¼€å‘è€…ï¼Œæˆ‘ä»¬æ˜¯å¦çœŸæ­£ç†è§£å®ƒçš„å·¥ä½œåŸç†ï¼Ÿé€šè¿‡ä»é›¶å®ç°ä¸€ä¸ª Mini-ESLintï¼Œæˆ‘ä»¬å¯ä»¥ï¼š

- **æ·±å…¥ç†è§£ ASTï¼ˆæŠ½è±¡è¯­æ³•æ ‘ï¼‰**ï¼šæŒæ¡ä»£ç æ˜¯å¦‚ä½•è¢«è§£æå’Œåˆ†æçš„
- **å­¦ä¹ ç¼–è¯‘åŸç†å®è·µ**ï¼šå°†ç†è®ºçŸ¥è¯†è½¬åŒ–ä¸ºå®é™…çš„å·¥ç¨‹èƒ½åŠ›
- **æŒæ¡å·¥å…·é“¾å¼€å‘**ï¼šäº†è§£å¦‚ä½•æ„å»ºå¼€å‘è€…å·¥å…·
- **æå‡ä»£ç åˆ†æèƒ½åŠ›**ï¼šä¸ºåç»­å¼€å‘æ›´å¤æ‚çš„ä»£ç å·¥å…·æ‰“åŸºç¡€

### æ ¸å¿ƒæŠ€æœ¯æ ˆ

| æŠ€æœ¯ç»„ä»¶     | é€‰æ‹©æ–¹æ¡ˆ     | é€‰æ‹©ç†ç”±                           |
| ------------ | ------------ | ---------------------------------- |
| **è§£æå™¨**   | Espree       | ESLint å®˜æ–¹è§£æå™¨ï¼ŒESTree æ ‡å‡†å…¼å®¹ |
| **å¼€å‘è¯­è¨€** | TypeScript   | ç±»å‹å®‰å…¨ï¼Œå¼€å‘ä½“éªŒå¥½               |
| **æ„å»ºå·¥å…·** | esbuild      | æ„å»ºé€Ÿåº¦å¿«ï¼Œé…ç½®ç®€å•               |
| **æµ‹è¯•æ¡†æ¶** | Vitest       | ç°ä»£åŒ–ï¼Œä¸ Vite ç”Ÿæ€å…¼å®¹           |
| **CLI æ¡†æ¶** | Commander.js | åŠŸèƒ½å®Œå–„ï¼Œç¤¾åŒºæˆç†Ÿ                 |

## 2. æ•´ä½“æ¶æ„è®¾è®¡ä¸å®ç°

### 2.1 æ•´ä½“æ¶æ„è®¾è®¡

#### 2.1.1 åŸºç¡€ç±»è®¾è®¡

æˆ‘ä»¬å¯ä»¥æŠŠä»£ç åˆ†æï¼Œæ‰¾å‡ºé—®é¢˜çš„è¿‡ç¨‹ä¸­è®¾è®¡çš„å˜é‡å’Œæ–¹æ³•ï¼Œéƒ½å°è£…åœ¨ä¸€ä¸ªåä¸º Linter çš„ç±»ä¸­ã€‚å¯ä»¥æŠŠå®ƒç†è§£æˆä»£ç åˆ†ææµç¨‹çš„æŠ½è±¡ï¼Œå®ƒæ˜¯ mini-eslint çš„æ ¸å¿ƒï¼Œé€šè¿‡ new ç”Ÿæˆåˆ†æå®ä¾‹åï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡åˆ†æå®ä¾‹æ¥é©±åŠ¨æ•´ä¸ªåˆ†ææµç¨‹ã€‚
ä¸‹é¢æ˜¯ Linter åŸºç¡€ç±»çš„ä»£ç æ¡†æ¶ç®€åŒ–ç‰ˆæ¼”ç¤ºï¼š

```typescript
/**
 * Linter åŸºç¡€ç±»
 * è¿™æ˜¯ mini-eslint çš„æ ¸å¿ƒç±»ï¼Œå°è£…äº†ä»£ç åˆ†ææµç¨‹çš„æŠ½è±¡
 * è®¾è®¡ç†å¿µï¼š
 * - å•ä¸€èŒè´£ï¼šä¸“æ³¨äºä»£ç åˆ†ææµç¨‹ç¼–æ’
 * - å¼‚æ­¥ä¼˜å…ˆï¼šæ”¯æŒå¤§è§„æ¨¡æ–‡ä»¶å¹¶è¡Œå¤„ç†
 * - å¯æ‰©å±•æ€§ï¼šæ’ä»¶åŒ–è§„åˆ™ç³»ç»Ÿ
 */
export class Linter {
  /** æ–‡ä»¶æ¨¡å¼åˆ—è¡¨ï¼Œæ”¯æŒ glob è¯­æ³• */
  private filePatterns: string[];

  /** åŠ è½½çš„è§„åˆ™å®ä¾‹åˆ—è¡¨ */
  private rules: Rule[];

  /** æ”¶é›†çš„é”™è¯¯ä¿¡æ¯ */
  private errors: LintError[];

  /** åˆå¹¶åçš„é…ç½®å¯¹è±¡ */
  private config: any;

  /** å¼‚æ­¥åˆ†æå®Œæˆæ ‡å¿— */
  private analysisComplete: Promise<void>;

  /**
   * æ„é€ å‡½æ•° - åˆå§‹åŒ–åˆ†æå®ä¾‹
   * @param options é…ç½®é€‰é¡¹
   */
  constructor(options: { files: string[]; configFile?: string }) {
    // 1. å­˜å‚¨æ–‡ä»¶æ¨¡å¼
    this.filePatterns = options.files;
    this.errors = [];

    // 2. é…ç½®ç³»ç»Ÿåˆå§‹åŒ–
    this.config = this.loadConfig(options.configFile);

    // 3. è§„åˆ™ç³»ç»Ÿæ¿€æ´»
    this.initRules();

    // 4. å¯åŠ¨å¼‚æ­¥åˆ†ææµç¨‹
    this.analysisComplete = this.startAnalysis();
  }

  /**
   * é…ç½®åŠ è½½ä¸åˆå¹¶
   * æ”¯æŒ JSON å’Œ JS æ ¼å¼çš„é…ç½®æ–‡ä»¶
   */
  private loadConfig(configFile?: string): any {
    // é…ç½®æ–‡ä»¶åŠ è½½é€»è¾‘
    // æ”¯æŒç”¨æˆ·é…ç½®è¦†ç›–é»˜è®¤é…ç½®
    return {}; // ç®€åŒ–å®ç°
  }

  /**
   * è§„åˆ™ç³»ç»Ÿåˆå§‹åŒ–
   * æ ¹æ®é…ç½®åŠ è½½å’Œè¿‡æ»¤è§„åˆ™
   */
  private initRules(): void {
    // è§„åˆ™åŠ è½½å’Œå®ä¾‹åŒ–é€»è¾‘
    this.rules = [];
  }

  /**
   * å¯åŠ¨åˆ†ææµç¨‹
   * æ–‡ä»¶æ‰«æ â†’ è§£æ â†’ è§„åˆ™åº”ç”¨
   */
  private async startAnalysis(): Promise<void> {
    // 1. æ–‡ä»¶å‘ç°ä¸æ‰«æ
    const files = await this.scanFiles();

    // 2. å¹¶è¡Œæ–‡ä»¶è§£æ
    await this.parseFiles(files);
  }

  /**
   * æ–‡ä»¶æ‰«æç³»ç»Ÿ
   * å°† glob æ¨¡å¼è½¬æ¢ä¸ºå…·ä½“æ–‡ä»¶åˆ—è¡¨
   */
  private async scanFiles(): Promise<string[]> {
    // glob æ¨¡å¼åŒ¹é…é€»è¾‘
    // å»é‡å’Œè¿‡æ»¤å¤„ç†
    return [];
  }

  /**
   * å¹¶è¡Œæ–‡ä»¶è§£æ
   * åŒæ—¶å¤„ç†å¤šä¸ªæ–‡ä»¶ä»¥æå‡æ€§èƒ½
   */
  private async parseFiles(files: string[]): Promise<void> {
    // Promise.all å¹¶è¡Œå¤„ç†
    await Promise.all(files.map((file) => this.parseFile(file)));
  }

  /**
   * å•æ–‡ä»¶è§£ææ ¸å¿ƒæµç¨‹
   * æºä»£ç  â†’ AST â†’ è§„åˆ™åº”ç”¨
   */
  private async parseFile(filePath: string): Promise<void> {
    try {
      // 1. è¯»å–æºä»£ç 
      const sourceCode = this.readSourceCode(filePath);

      // 2. ç”Ÿæˆ AST
      const ast = this.parseToAST(sourceCode, filePath);

      // 3. åº”ç”¨è§„åˆ™åˆ†æ
      await this.analyzeAST(ast, filePath, sourceCode);
    } catch (error) {
      // é”™è¯¯å¤„ç†å’ŒæŠ¥å‘Š
      this.handleParseError(error, filePath);
    }
  }

  /**
   * æºä»£ç è¯»å–
   */
  private readSourceCode(filePath: string): string {
    // æ–‡ä»¶è¯»å–é€»è¾‘
    return "";
  }

  /**
   * AST è§£æ
   * ä½¿ç”¨ Espree è§£æå™¨ç”ŸæˆæŠ½è±¡è¯­æ³•æ ‘
   */
  private parseToAST(sourceCode: string, filePath: string): any {
    // Espree è§£æé…ç½®
    // æ”¯æŒ JSXã€TypeScript ç­‰
    return {};
  }

  /**
   * AST åˆ†æä¸è§„åˆ™åº”ç”¨
   * éå† AST èŠ‚ç‚¹ï¼Œè§¦å‘è§„åˆ™æ£€æŸ¥
   */
  private async analyzeAST(
    ast: any,
    filePath: string,
    sourceCode: string
  ): Promise<void> {
    // éå†æ‰€æœ‰æ¿€æ´»çš„è§„åˆ™
    for (const rule of this.rules) {
      // åˆ›å»ºè§„åˆ™ä¸Šä¸‹æ–‡
      const context = this.createRuleContext(rule, filePath);

      // åˆ›å»ºè§„åˆ™ç›‘å¬å™¨
      const listener = rule.create(context);

      // éå† AST åº”ç”¨è§„åˆ™
      this.traverseAST(ast, listener);
    }
  }

  /**
   * åˆ›å»ºè§„åˆ™ä¸Šä¸‹æ–‡
   * ä¸ºè§„åˆ™æä¾›æŠ¥å‘Šé”™è¯¯çš„èƒ½åŠ›
   */
  private createRuleContext(rule: any, filePath: string): any {
    return {
      report: (data: any) => {
        // æ”¶é›†é”™è¯¯ä¿¡æ¯
        this.errors.push({
          ...data,
          filePath,
          ruleId: rule.meta.name,
        });
      },
      options: this.getRuleOptions(rule),
      getSourceCode: () => this.getSourceCode(filePath),
    };
  }

  /**
   * AST éå†
   * æ·±åº¦ä¼˜å…ˆéå†ï¼Œè§¦å‘èŠ‚ç‚¹äº‹ä»¶
   */
  private traverseAST(ast: any, listener: any): void {
    // æ·±åº¦ä¼˜å…ˆéå†é€»è¾‘
    // è§¦å‘èŠ‚ç‚¹è¿›å…¥å’Œé€€å‡ºäº‹ä»¶
  }

  /**
   * è·å–è§„åˆ™é…ç½®é€‰é¡¹
   */
  private getRuleOptions(rule: any): any[] {
    // è§£æè§„åˆ™é…ç½®é€‰é¡¹
    return [];
  }

  /**
   * é”™è¯¯å¤„ç†
   */
  private handleParseError(error: any, filePath: string): void {
    // åˆ†ç±»å¤„ç†è¯­æ³•é”™è¯¯å’Œè§£æé”™è¯¯
    console.error(`è§£ææ–‡ä»¶ ${filePath} æ—¶å‡ºé”™:`, error);
  }

  /**
   * è·å–æºä»£ç 
   */
  private getSourceCode(filePath: string): string {
    // è¿”å›æŒ‡å®šæ–‡ä»¶çš„æºä»£ç 
    return "";
  }

  /**
   * è·å–åˆ†æç»“æœ
   * ç­‰å¾…æ‰€æœ‰å¼‚æ­¥åˆ†æå®Œæˆåè¿”å›é”™è¯¯åˆ—è¡¨
   */
  public async getErrors(): Promise<LintError[]> {
    // ç­‰å¾…åˆ†æå®Œæˆ
    await this.analysisComplete;
    return this.errors;
  }

  /**
   * è·å–åˆ†æç»Ÿè®¡ä¿¡æ¯
   */
  public getStats(): AnalysisStats {
    return {
      filesProcessed: this.filePatterns.length,
      errorsFound: this.errors.length,
      rulesApplied: this.rules.length,
    };
  }
}
```

åŸºç¡€ç±»ä¸­åŒ…æ‹¬è¾“å…¥çš„æ–‡ä»¶æ¨¡å¼åˆ—è¡¨ã€è§„åˆ™åˆ—è¡¨ã€é”™è¯¯ä¿¡æ¯åˆ—è¡¨ã€é…ç½®ã€åˆ†æå®Œæˆçš„ Promiseã€é…ç½®æ–‡ä»¶åŠ è½½æ–¹æ³•ã€è§„åˆ™åˆå§‹åŒ–æ–¹æ³•ã€æ–‡ä»¶æ‰«æå’Œè§£ææ–¹æ³•ã€æ‰¹é‡æ–‡ä»¶è§£ææ–¹æ³•ã€å•ä¸ªæ–‡ä»¶è§£ææ–¹æ³•ã€æŠ½è±¡è¯­æ³•æ ‘åˆ†ææ–¹æ³•ã€è§„åˆ™é€‰é¡¹è·å–æ–¹æ³•ã€é”™è¯¯ä¿¡æ¯è·å–æ–¹æ³•ã€‚è¿™äº›åœ¨åç»­æˆ‘ä»¬éƒ½ä¼šå…·ä½“ä»‹ç»å®ç°ã€‚

#### 2.1.2 æ‰§è¡Œç”Ÿå‘½å‘¨æœŸ

æˆ‘ä»¬æ ¹æ® mini-eslint å…¥å£å‡½æ•° cli çš„è¯¦ç»†è°ƒç”¨é“¾è·¯ï¼Œå°†å·¥å…·çš„æ‰§è¡Œæ—¶åºæ¢³ç†åï¼Œå¯ä»¥å¾—åˆ° mini-eslint çš„æ‰§è¡Œç”Ÿå‘½å‘¨æœŸï¼š

![image](img/1-2.png)

#### 2.1.3 æ¨¡å—æ¶æ„å›¾

ä»…ä»…é ä¸€ä¸ª Linter åŸºç¡€ç±»æ˜¯æ— æ³•å®Œæˆä¾èµ–è°ƒç”¨åˆ†ææ•´ä¸ªæµç¨‹çš„ï¼Œå®ƒæ˜¯åˆ†æå·¥å…·çš„æ ¸å¿ƒï¼Œä½†ä¸æ˜¯å…¨éƒ¨ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å…¶å®ƒæ¨¡å—æ¥è¾…åŠ©å®ƒå®Œæˆåˆ†æä»»åŠ¡ï¼Œä»£ç åˆ†æå·¥å…·çš„æ¶æ„è®¾è®¡å¦‚ä¸‹å›¾ï¼š

![image](img/1-1.png)

**æ¨¡å—é—´é€šä¿¡åŸåˆ™ï¼š**

- æ ¸å¿ƒå±‚å‘ä¸Šæä¾›ç¨³å®š API
- è§„åˆ™å±‚é€šè¿‡æ’ä»¶æœºåˆ¶æ‰©å±•
- å‘½ä»¤è¡Œå±‚è´Ÿè´£ç”¨æˆ·äº¤äº’

å¯ä»¥å¯¹ç…§[å®Œæ•´ä»£ç ](https://github.com/lzj2000/mini-eslint)æ¥ç†è§£ mini-eslint çš„ä»£ç ç»„ç»‡æ¨¡å¼ã€‚

### 2.3 å…·ä½“å®ç°

#### 2.3.1 AST å¤„ç†ä¸å·¥å…·

##### AST è§£æä¸å¤„ç†è¯¦è§£

**ä»€ä¹ˆæ˜¯ ASTï¼ˆæŠ½è±¡è¯­æ³•æ ‘ï¼‰ï¼Ÿ**

æŠ½è±¡è¯­æ³•æ ‘ï¼ˆAbstract Syntax Treeï¼Œç®€ç§° ASTï¼‰æ˜¯æºä»£ç è¯­æ³•ç»“æ„çš„æ ‘å½¢æŠ½è±¡è¡¨ç¤ºã€‚å®ƒå°†ä»£ç çš„è¯­æ³•ç»“æ„ä»¥å±‚æ¬¡åŒ–çš„èŠ‚ç‚¹å½¢å¼ç»„ç»‡ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨æºä»£ç ä¸­çš„ä¸€ä¸ªè¯­æ³•æ„é€ ã€‚

**ä¸ºä»€ä¹ˆéœ€è¦ ASTï¼Ÿ**

åœ¨ä»£ç é™æ€åˆ†æä¸­ï¼ŒAST å…·æœ‰ä»¥ä¸‹é‡è¦ä½œç”¨ï¼š

- **ç»“æ„åŒ–è¡¨ç¤º**ï¼šå°†çº¿æ€§çš„æºä»£ç è½¬æ¢ä¸ºç»“æ„åŒ–çš„æ ‘å½¢æ•°æ®
- **è¯­æ³•æ— å…³æ€§**ï¼šæŠ½è±¡æ‰å…·ä½“çš„è¯­æ³•ç»†èŠ‚ï¼Œä¸“æ³¨äºè¯­ä¹‰ç»“æ„
- **ä¾¿äºåˆ†æ**ï¼šé€šè¿‡éå†æ ‘èŠ‚ç‚¹å¯ä»¥ç³»ç»Ÿåœ°åˆ†æä»£ç æ¨¡å¼
- **ä½ç½®ä¿¡æ¯**ï¼šä¿ç•™ä»£ç åœ¨æºæ–‡ä»¶ä¸­çš„ç²¾ç¡®ä½ç½®ï¼Œä¾¿äºé”™è¯¯å®šä½

**AST èŠ‚ç‚¹ç±»å‹è¯¦è§£**

è®©æˆ‘ä»¬é€šè¿‡å…·ä½“ç¤ºä¾‹äº†è§£å¸¸è§çš„ AST èŠ‚ç‚¹ç±»å‹ï¼š

**1. å­—é¢é‡ï¼ˆLiteralï¼‰èŠ‚ç‚¹**

```javascript
// å„ç§å­—é¢é‡åŠå…¶å¯¹åº”çš„ AST èŠ‚ç‚¹ç±»å‹
let name = "xl"; // 'xl' â†’ StringLiteralï¼ˆå­—ç¬¦ä¸²å­—é¢é‡ï¼‰
let age = 20; // 20 â†’ NumericLiteralï¼ˆæ•°å­—å­—é¢é‡ï¼‰
```

**2. æ ‡è¯†ç¬¦ï¼ˆIdentifierï¼‰èŠ‚ç‚¹**

```javascript
// æ ‡è¯†ç¬¦ï¼šå˜é‡åã€å‡½æ•°åã€å±æ€§åç­‰
import { glob } from "glob"; // glob â†’ Identifier
let name = "xl"; // name â†’ Identifier
```

**3. è¯­å¥ï¼ˆStatementï¼‰èŠ‚ç‚¹**

```javascript
// è¯­å¥ï¼šä»£ç æ‰§è¡Œçš„åŸºæœ¬å•ä½
return userData; // ReturnStatementï¼ˆè¿”å›è¯­å¥ï¼‰
if (condition) {
  doSomething();
} // IfStatementï¼ˆæ¡ä»¶è¯­å¥ï¼‰
```

**4. å£°æ˜ï¼ˆDeclarationï¼‰èŠ‚ç‚¹**

```javascript
// å£°æ˜ï¼šç‰¹æ®Šçš„è¯­å¥ç±»å‹ï¼Œç”¨äºå£°æ˜å˜é‡ã€å‡½æ•°ã€ç±»ç­‰
let name = "xl"; // VariableDeclarationï¼ˆå˜é‡å£°æ˜ï¼‰
let age = 20; // VariableDeclarationï¼ˆå˜é‡å£°æ˜ï¼‰
import fs from "fs"; // ImportDeclarationï¼ˆå¯¼å…¥å£°æ˜ï¼‰
```

**5. å¯¼å…¥å¯¼å‡ºèŠ‚ç‚¹**

```javascript
// é»˜è®¤å¯¼å…¥
import React from "react"; // ImportDeclaration + ImportDefaultSpecifier

// å‘½åå¯¼å…¥
import { useState, useEffect } from "react"; // ImportDeclaration + ImportSpecifier

// å‘½åç©ºé—´å¯¼å…¥
import * as fs from "fs"; // ImportDeclaration + ImportNamespaceSpecifier

// æ··åˆå¯¼å…¥
import React, { Component } from "react"; // ImportDeclaration + å¤šç§ Specifier

// é»˜è®¤å¯¼å‡º
export default function App() {} // ExportDefaultDeclaration

// å‘½åå¯¼å‡º
export const config = {}; // ExportNamedDeclaration

// é‡æ–°å¯¼å‡º
export { Button } from "./components"; // ExportNamedDeclaration + ExportSpecifier
```

**AST å¯è§†åŒ–å·¥å…·**

ä¸ºäº†æ›´å¥½åœ°ç†è§£ AST ç»“æ„ï¼Œæ¨èä½¿ç”¨ä»¥ä¸‹å·¥å…·ï¼š

1.  **[AST Explorer](https://astexplorer.net/#/gist/f9da6d62623c8e6cb359c76f54b26b1a/6189496315da4ae42aebb4f3c63f7fa4c442bcba)**

    - åœ¨çº¿ AST å¯è§†åŒ–å·¥å…·
    - æ”¯æŒå¤šç§ç¼–ç¨‹è¯­è¨€å’Œè§£æå™¨
    - å®æ—¶æ˜¾ç¤ºä»£ç å¯¹åº”çš„ AST ç»“æ„
    - å¯ä»¥åˆ‡æ¢ä¸åŒçš„ parserï¼ˆå¦‚ espreeã€babel ç­‰ï¼‰

2.  **ä½¿ç”¨ç¤ºä¾‹**

    ```javascript
    // åœ¨ AST Explorer ä¸­è¾“å…¥è¿™æ®µä»£ç 
    const message = "Hello World";
    console.log(message);

    // å¯ä»¥çœ‹åˆ°å¯¹åº”çš„ AST ç»“æ„ï¼š
    // Program
    // â””â”€â”€ VariableDeclaration
    //     â””â”€â”€ VariableDeclarator
    //         â”œâ”€â”€ Identifier (message)
    //         â””â”€â”€ Literal ("Hello World")
    // â””â”€â”€ ExpressionStatement
    //     â””â”€â”€ CallExpression
    //         â”œâ”€â”€ MemberExpression
    //         â”‚   â”œâ”€â”€ Identifier (console)
    //         â”‚   â””â”€â”€ Identifier (log)
    //         â””â”€â”€ Identifier (message)
    ```

![image](img/1-3.png)

**åœ¨ Mini ESLint ä¸­çš„ AST åº”ç”¨**

åœ¨æˆ‘ä»¬çš„ Mini ESLint å®ç°ä¸­ï¼ŒAST çš„å¤„ç†æµç¨‹å¦‚ä¸‹ï¼š

1.  **è§£æé˜¶æ®µ**ï¼šä½¿ç”¨ Espree å°†æºä»£ç è§£æä¸º AST
2.  **éå†é˜¶æ®µ**ï¼šæ·±åº¦ä¼˜å…ˆéå†æ‰€æœ‰èŠ‚ç‚¹
3.  **è§„åˆ™åº”ç”¨**ï¼šæ¯ä¸ªè§„åˆ™ç›‘å¬ç‰¹å®šç±»å‹çš„èŠ‚ç‚¹äº‹ä»¶
4.  **é”™è¯¯æ”¶é›†**ï¼šè§„åˆ™åœ¨æ£€æµ‹åˆ°é—®é¢˜æ—¶æŠ¥å‘Šé”™è¯¯ä¿¡æ¯

#### 2.3.2 CLI å¯åŠ¨ä¸ç¯å¢ƒåˆå§‹åŒ–

##### CLI æ¨¡å¼æ¦‚è¿°

CLI æ¨¡å¼å³å‘½ä»¤è¡Œæ¨¡å¼ï¼Œå¯ä»¥é…åˆ npm script æ¥é©±åŠ¨ï¼Œå…¥å£ä¸ºå¯æ‰§è¡Œè„šæœ¬ã€‚å‘½ä»¤è¡Œæ¨¡å¼åœ¨åˆ†æå‰ä¼šå¯¹å‘½ä»¤è¡Œå‚æ•°ä»¥åŠé…ç½®æ–‡ä»¶å‚æ•°è¿›è¡Œæ ¡éªŒï¼Œå¯¹åˆ†æç¯å¢ƒè¿›è¡Œé¢„å¤„ç†ã€‚

##### é¡¹ç›®å…¥å£ä¸æ„å»ºæµç¨‹

**1. å¯æ‰§è¡Œæ–‡ä»¶å…¥å£**

é¡¹ç›®é€šè¿‡ `package.json` ä¸­çš„ `bin` å­—æ®µå®šä¹‰äº†å¯æ‰§è¡Œå‘½ä»¤ï¼ˆæŒ‡å®š**å¯æ‰§è¡Œæ–‡ä»¶**çš„è·¯å¾„ï¼‰ï¼š

```json
{
  "bin": {
    "minlint": "bin/minlint.js"
  }
}
```

`bin/minlint.js` ä½œä¸ºå¯æ‰§è¡Œè„šæœ¬çš„å…¥å£ï¼Œç¬¬ä¸€è¡Œçš„ `#!/usr/bin/env node` è¡¨ç¤ºè¯¥æ–‡ä»¶æ˜¯ä¸€ä¸ªå¯æ‰§è¡Œè„šæœ¬ï¼š

```js
#!/usr/bin/env node

require("../dist/cli.js");
```

##### CLI æ ¸å¿ƒå®ç°

**ä¾èµ–å¯¼å…¥ä¸ç¨‹åºåˆå§‹åŒ–**

```js
import { Command } from "commander";
import chalk from "chalk";
import fs from "fs";
import path from "path";

import { version } from "../package.json";
import { Linter } from "./linter";
import { stylish } from "./formatter/stylish";

const program = new Command();

// ç¨‹åºæ ‡é¢˜
console.log(chalk.bold.cyan("\n=== MiniESLint ===") + " è½»é‡çº§ä»£ç æ£€æŸ¥å·¥å…·\n");

program
  .name("mini-eslint")
  .description("ä¸€ä¸ªè½»é‡çº§ä»£ç æ£€æŸ¥å·¥å…·")
  .version(version, "-v, --version", "æ˜¾ç¤ºç‰ˆæœ¬å·")
  .argument(
    "[files...]",
    'è¦æ£€æŸ¥çš„æ–‡ä»¶æˆ–globæ¨¡å¼ï¼ˆé»˜è®¤: "src/**/*.{js,ts,jsx,tsx}"ï¼‰'
  )
  .option("-c, --config <path>", 'é…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆé»˜è®¤: ".minlintrc.{json,js}"ï¼‰')
  .action(async (files: string[], options: any) => {
    try {
      // å¤„ç†é…ç½®æ–‡ä»¶è·¯å¾„
      let configFile = options.config;
      if (!configFile) {
        const defaultConfigPaths = [
          path.join(process.cwd(), ".minlintrc.json"),
          path.join(process.cwd(), ".minlintrc.js"),
        ];
        for (const configPath of defaultConfigPaths) {
          if (fs.existsSync(configPath)) {
            configFile = configPath;
            break;
          }
        }
      }

      // å¤„ç†æ–‡ä»¶è·¯å¾„
      if (files.length === 0) {
        files = ["src/**/*.{js,ts,jsx,tsx}"];
        if (!fs.existsSync(path.join(process.cwd(), "src"))) {
          console.log(
            chalk.yellow("æ³¨æ„: 'src' ç›®å½•ä¸å­˜åœ¨ï¼Œå°†æ£€æŸ¥å½“å‰ç›®å½•ä¸‹çš„æ‰€æœ‰JSæ–‡ä»¶")
          );
          files = ["**/*.{js,ts,jsx,tsx}"];
        }
      }

      // åˆå§‹åŒ–Linterå¹¶æ‰§è¡Œæ£€æŸ¥
      const linter = new Linter({ files, configFile });
      const errors = await linter.getErrors();
      stylish(errors);

      // è®¾ç½®é€€å‡ºç 
      process.exitCode = errors.length > 0 ? 1 : 0;
    } catch (error) {
      console.error(error);
      process.exit(1);
    }
  });

// è§£æå‘½ä»¤è¡Œå‚æ•°
program.parse(process.argv);
```

ä¸Šè¿°ä»£ç ä½¿ç”¨äº†è¿™äº›æ ¸å¿ƒä¾èµ–åŒ…ï¼š

- **commander**: å‘½ä»¤è¡Œå‚æ•°è§£æå’Œå‘½ä»¤å®šä¹‰
- **chalk**: ç»ˆç«¯å½©è‰²è¾“å‡º
- **fs/path**: Node.js å†…ç½®æ–‡ä»¶ç³»ç»Ÿå’Œè·¯å¾„å¤„ç†æ¨¡å—

**æ ¸å¿ƒå¤„ç†æµç¨‹**ï¼š

1.  é…ç½®æ–‡ä»¶è‡ªåŠ¨å‘ç°ï¼ˆä¼˜å…ˆç”¨æˆ·æŒ‡å®šï¼Œå…¶æ¬¡æŸ¥æ‰¾é»˜è®¤é…ç½®ï¼‰
2.  æ–‡ä»¶è·¯å¾„æ™ºèƒ½å¤„ç†ï¼ˆé»˜è®¤ src ç›®å½•ï¼Œå›é€€åˆ°å½“å‰ç›®å½•ï¼‰
3.  Linter å¼•æ“åˆå§‹åŒ–å’Œæ‰§è¡Œ
4.  ç»“æœæ ¼å¼åŒ–è¾“å‡ºå’Œé€€å‡ºç è®¾ç½®

#### 2.3.3 Linter æ ¸å¿ƒå¼•æ“å®ç°

##### Linter ç±»æ¶æ„è®¾è®¡

**ç±»å±æ€§è®¾è®¡è¯´æ˜**

```typescript
export class Linter {
  private filePatterns: string[]; // æ–‡ä»¶æ¨¡å¼æ•°ç»„ï¼Œæ”¯æŒ glob è¯­æ³•
  private rules: Rule[]; // åŠ è½½çš„è§„åˆ™å®ä¾‹åˆ—è¡¨
  private errors: LintError[]; // æ”¶é›†çš„é”™è¯¯ä¿¡æ¯
  private config; // åˆå¹¶åçš„é…ç½®å¯¹è±¡
  private analysisComplete: Promise<void>; // å¼‚æ­¥åˆ†æå®Œæˆæ ‡å¿—
}
```

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ**

1.  **å¼‚æ­¥æ¶æ„**ï¼š`analysisComplete` Promise ç¡®ä¿æ‰€æœ‰æ–‡ä»¶åˆ†æå®Œæˆåæ‰è¿”å›ç»“æœ
2.  **é”™è¯¯æ”¶é›†**ï¼š`errors` æ•°ç»„é›†ä¸­ç®¡ç†æ‰€æœ‰æ–‡ä»¶çš„æ£€æŸ¥ç»“æœ
3.  **é…ç½®é©±åŠ¨**ï¼š`config` å¯¹è±¡æ§åˆ¶è§„åˆ™å¯ç”¨çŠ¶æ€å’Œé€‰é¡¹
4.  **è§„åˆ™å®ä¾‹åŒ–**ï¼š`rules` æ•°ç»„åŒ…å«æ‰€æœ‰æ¿€æ´»çš„è§„åˆ™å®ä¾‹

##### Linter æ ¸å¿ƒå¼•æ“å®ç°

```typescript
constructor(options: { files: string[]; configFile?: string }) {
  this.filePatterns = options.files;
  this.errors = [];
  this.rules = [];

  // é…ç½®æ–‡ä»¶åŠ è½½ä¸åˆå¹¶
  if (options.configFile) {
    this.config = this.loadConfigFile(options.configFile);
  } else {
    this.config = defaultConfig;
  }

  // è§„åˆ™åˆå§‹åŒ–
  this.initRules();

  // å¯åŠ¨å¼‚æ­¥æ–‡ä»¶æ‰«æå’Œè§£ææµç¨‹
  this.analysisComplete = this.scanAndParseFiles();
}
```

åˆå§‹åŒ–æµç¨‹è¯´æ˜ï¼š

1.  **æ–‡ä»¶æ¨¡å¼å­˜å‚¨**ï¼šå°†ç”¨æˆ·æä¾›çš„æ–‡ä»¶æ¨¡å¼ï¼ˆæ”¯æŒ glob è¯­æ³•ï¼‰å­˜å‚¨åˆ° filePatterns å±æ€§
2.  **é”™è¯¯å®¹å™¨åˆå§‹åŒ–**ï¼šåˆ›å»ºç©ºçš„é”™è¯¯æ•°ç»„ç”¨äºæ”¶é›†æ‰€æœ‰æ£€æŸ¥ç»“æœ
3.  **é…ç½®ç³»ç»Ÿå¯åŠ¨**ï¼šæ ¹æ®æ˜¯å¦æä¾›é…ç½®æ–‡ä»¶è·¯å¾„ï¼Œé€‰æ‹©åŠ è½½ç”¨æˆ·é…ç½®æˆ–ä½¿ç”¨é»˜è®¤é…ç½®
4.  **è§„åˆ™ç³»ç»Ÿæ¿€æ´»**ï¼šè°ƒç”¨ initRules() æ–¹æ³•åŠ è½½å’Œè¿‡æ»¤è§„åˆ™
5.  **å¼‚æ­¥åˆ†æå¯åŠ¨**ï¼šç«‹å³å¼€å§‹æ–‡ä»¶æ‰«æå’Œè§£ææµç¨‹ï¼Œä½†ä¸é˜»å¡æ„é€ å‡½æ•°è¿”å›

##### é…ç½®ç³»ç»Ÿè§£æ

é…ç½®æ–‡ä»¶åŠ è½½æ˜¯ Linter åˆå§‹åŒ–çš„å…³é”®æ­¥éª¤ï¼Œå®ƒå†³å®šäº†å“ªäº›è§„åˆ™ä¼šè¢«åº”ç”¨ä»¥åŠå¦‚ä½•åº”ç”¨ï¼š

```typescript
private loadConfigFile(configFilePath: string) {
  try {
    const configFileContent = fs.readFileSync(configFilePath, "utf-8");
    const fileExtension = path.extname(configFilePath);

    let userConfig;
    if (fileExtension === ".json") {
      userConfig = JSON.parse(configFileContent);  // JSON æ ¼å¼è§£æ
    } else if (fileExtension === ".js") {
      const absolutePath = path.resolve(configFilePath);
      userConfig = require(absolutePath);          // JS æ¨¡å—åŠ è½½
    } else {
      throw new Error(`ä¸æ”¯æŒçš„é…ç½®æ–‡ä»¶æ ¼å¼: ${fileExtension}`);
    }

    // é…ç½®åˆå¹¶ç­–ç•¥ï¼šç”¨æˆ·é…ç½®è¦†ç›–é»˜è®¤é…ç½®
    const mergedConfig = mergeConfigs(defaultConfig, userConfig);
    return mergedConfig;
  } catch (error) {
    console.warn(`è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®: ${error.message}`);
    return defaultConfig;
  }
}
```

è¿™ä¸ªæ–¹æ³•å®ç°é…ç½®åŠ è½½æœºåˆ¶ï¼šæ”¯æŒ JSON å’Œ JS ä¸¤ç§æ ¼å¼ï¼›ä½¿ç”¨ `path.resolve()` ç¡®ä¿ require èƒ½æ­£ç¡®åŠ è½½ JS é…ç½®æ–‡ä»¶ï¼›é…ç½®åŠ è½½å¤±è´¥æ—¶è‡ªåŠ¨é™çº§åˆ°é»˜è®¤é…ç½®ï¼Œä¿è¯ Linter å§‹ç»ˆèƒ½å¤Ÿè¿è¡Œã€‚é…ç½®åˆå¹¶ç­–ç•¥è®©ç”¨æˆ·å¯ä»¥åªè¦†ç›–éœ€è¦ä¿®æ”¹çš„éƒ¨åˆ†ï¼Œè€Œä¸å¿…é‡æ–°å®šä¹‰æ•´ä¸ªé…ç½®ã€‚

##### æ–‡ä»¶å‘ç°ä¸æ‰«æç³»ç»Ÿ

æ–‡ä»¶æ‰«ææ˜¯ Linter å·¥ä½œæµç¨‹çš„ç¬¬ä¸€æ­¥ï¼Œéœ€è¦å°†ç”¨æˆ·æä¾›çš„æ–‡ä»¶æ¨¡å¼è½¬æ¢ä¸ºå…·ä½“çš„æ–‡ä»¶åˆ—è¡¨ï¼š

```typescript
private async scanAndParseFiles(): Promise<void> {
  let allMatchedFiles: string[] = [];

  // éå†æ¯ä¸ªæ–‡ä»¶æ¨¡å¼
  for (const pattern of this.filePatterns) {
    try {
      const matchedFiles = await glob(pattern, {
        ignore: "node_modules/**",    // æ€§èƒ½ä¼˜åŒ–ï¼šå¿½ç•¥ä¾èµ–ç›®å½•
        absolute: false,              // ä½¿ç”¨ç›¸å¯¹è·¯å¾„ä¾¿äºæ˜¾ç¤º
      });
      allMatchedFiles.push(...matchedFiles);
    } catch (error) {
      console.error(`å¤„ç†æ–‡ä»¶æ¨¡å¼ "${pattern}" æ—¶å‡ºé”™:`, error);
    }
  }

  // å»é‡å¤„ç†ï¼ˆé¿å…é‡å¤æ–‡ä»¶ï¼‰
  const uniqueFiles = [...new Set(allMatchedFiles)];
  await this.parseMultipleFiles(uniqueFiles);
}
```

è¿™ä¸ªæ–¹æ³•çš„ç›®çš„æ˜¯è·å–éœ€è¦åˆ†æçš„æ–‡ä»¶åˆ—è¡¨ï¼šè‡ªåŠ¨å¿½ç•¥ `node_modules` ç›®å½•é¿å…æ‰«æå¤§é‡æ— å…³æ–‡ä»¶ï¼Œä½¿ç”¨ Set æ•°æ®ç»“æ„è‡ªåŠ¨å»é‡ï¼Œé”™è¯¯éš”ç¦»ç¡®ä¿å•ä¸ªæ¨¡å¼å¤±è´¥ä¸å½±å“å…¶ä»–æ¨¡å¼ã€‚æ‰«æå®Œæˆåç›´æ¥è°ƒç”¨æ‰¹é‡è§£ææ–¹æ³•ã€‚

é…ç½®åˆå¹¶ç­–ç•¥ï¼Œå°†ç”¨æˆ·é…ç½®ä¸é»˜è®¤é…ç½®åˆå¹¶ï¼Œç”¨æˆ·é…ç½®ä¼˜å…ˆçº§é«˜ï¼š

```typescript
export function mergeConfigs(defaultConfig: any, userConfig: any): any {
  const merged = { ...defaultConfig };

  if (userConfig.rules) {
    merged.rules = { ...defaultConfig.rules, ...userConfig.rules };
  }

  return merged;
}
```

##### å¹¶è¡Œæ–‡ä»¶è§£ææ¶æ„

å¹¶è¡Œå¤„ç†ç­–ç•¥åŒæ—¶è§£æå¤šä¸ªæ–‡ä»¶ï¼š

```typescript
private async parseMultipleFiles(files: string[]): Promise<void> {
  // Promise.all å®ç°å¹¶è¡Œå¤„ç†ï¼Œæå‡æ€§èƒ½
  await Promise.all(
    files.map(async (file) => {
      try {
        await this.parseSingleFile(file);
      } catch (error) {
        console.error(`è§£ææ–‡ä»¶ ${file} æ—¶å‡ºé”™:`, error);
        // å•æ–‡ä»¶é”™è¯¯ä¸ä¸­æ–­æ•´ä½“æµç¨‹
      }
    })
  );
}
```

**å•æ–‡ä»¶ AST è§£ææµç¨‹**

å•æ–‡ä»¶è§£ææ˜¯æ•´ä¸ª Linter ç³»ç»Ÿçš„æ ¸å¿ƒç¯èŠ‚ï¼Œå®ƒå°†æºä»£ç è½¬æ¢ä¸ºå¯åˆ†æçš„ AST ç»“æ„ï¼š

```typescript
async parseSingleFile(filePath: string) {
  try {
    // 1. è¯»å–æºä»£ç 
    const sourceCode = fs.readFileSync(filePath, "utf-8");

    // 2. æ–‡ä»¶ç±»å‹æ£€æµ‹
    const fileExtension = path.extname(filePath);
    const isJSXFile = fileExtension === ".jsx" || fileExtension === ".tsx";

    // 3. è§£æå™¨é…ç½®
    const parserOptions = {
      ecmaVersion: "latest" as const,
      sourceType: "module" as const,
      ecmaFeatures: {
        jsx: isJSXFile,              // åŠ¨æ€å¯ç”¨ JSX æ”¯æŒ
        globalReturn: false,
        impliedStrict: true,
      },
      range: true,                   // å­—ç¬¦ä½ç½®ä¿¡æ¯
      loc: true,                     // è¡Œåˆ—ä½ç½®ä¿¡æ¯
      comments: true,                // æ³¨é‡Šä¿ç•™
      tokens: true,                  // Token ä¿¡æ¯
    };

    // 4. ç”Ÿæˆ AST
    const abstractSyntaxTree = espree.parse(sourceCode, parserOptions);

    // 5. AST åˆ†æ
    await this.analyzeAbstractSyntaxTree(abstractSyntaxTree, filePath, sourceCode);

    return abstractSyntaxTree;
  } catch (error) {
    // é”™è¯¯åˆ†ç±»å¤„ç†
    if (error instanceof SyntaxError) {
      console.error(`âœ— è¯­æ³•é”™è¯¯ ${filePath}:`, error.message);
    } else {
      console.error(`âœ— è§£æé”™è¯¯ ${filePath}:`, error);
    }
    throw error;
  }
}
```

è¿™ä¸ªæ–¹æ³•ç›®çš„æ˜¯å°†ä»£ç è§£ææˆ ASTï¼šé¦–å…ˆè¯»å–æºä»£ç å†…å®¹ï¼Œç„¶åæ ¹æ®æ–‡ä»¶æ‰©å±•ååŠ¨æ€é…ç½®è§£æå™¨ï¼ˆJSX æ”¯æŒï¼‰ï¼Œæ¥ç€ä½¿ç”¨ Espree ç”Ÿæˆ ASTï¼Œæœ€åè°ƒç”¨åˆ†ææ–¹æ³•åº”ç”¨è§„åˆ™ã€‚é”™è¯¯å¤„ç†åŒºåˆ†äº†è¯­æ³•é”™è¯¯å’Œå…¶ä»–è§£æé”™è¯¯ï¼Œä¸ºç”¨æˆ·æä¾›æ›´ç²¾ç¡®çš„é”™è¯¯ä¿¡æ¯ã€‚ä½ç½®ä¿¡æ¯çš„ä¿ç•™ç¡®ä¿äº†åç»­é”™è¯¯æŠ¥å‘Šçš„å‡†ç¡®æ€§ã€‚

##### AST éå†ä¸è§„åˆ™åº”ç”¨

AST éå†æ˜¯ Linter çš„æ ¸å¿ƒæœºåˆ¶ï¼Œé€šè¿‡æ·±åº¦ä¼˜å…ˆéå†è®¿é—®æ¯ä¸ªèŠ‚ç‚¹ï¼Œå¹¶è§¦å‘å¯¹åº”çš„è§„åˆ™ç›‘å¬å™¨ï¼š

```typescript
// ast-utils.ts ä¸­çš„ traverse å‡½æ•° - æ ¸å¿ƒéå†é€»è¾‘
export function traverse(ast: AST, listener: RuleListener) {
  const visit = (node: ASTNode, parent: ASTNode | null = null) => {
    if (!node || typeof node !== "object") return;

    // è§¦å‘èŠ‚ç‚¹è¿›å…¥äº‹ä»¶
    if (node.type && typeof listener[node.type] === "function") {
      listener[node.type](node);
    }

    // å¤„ç†é€€å‡ºäº‹ä»¶ï¼ˆå¦‚ 'Program:exit'ï¼‰
    if (node.type && typeof listener[`${node.type}:exit`] === "function") {
      // å…ˆéå†å­èŠ‚ç‚¹ï¼Œå†è°ƒç”¨é€€å‡ºæ–¹æ³•
      for (const key in node) {
        if (key === "type" || key === "loc" || key === "range") continue;
        const child = node[key];
        if (Array.isArray(child)) {
          child.forEach((item) => visit(item, node));
        } else {
          visit(child, node);
        }
      }
      listener[`${node.type}:exit`](node);
      return;
    }

    // é€’å½’éå†å­èŠ‚ç‚¹
    for (const key in node) {
      if (key === "type" || key === "loc" || key === "range") continue;
      const child = node[key];
      if (Array.isArray(child)) {
        child.forEach((item) => visit(item, node));
      } else {
        visit(child, node);
      }
    }
  };

  visit(ast); // ä»æ ¹èŠ‚ç‚¹å¼€å§‹éå†
}
```

è¿™ä¸ªå‡½æ•°å®ç°äº†æ·±åº¦ä¼˜å…ˆéå†ï¼Œæ”¯æŒèŠ‚ç‚¹è¿›å…¥å’Œé€€å‡ºäº‹ä»¶ï¼Œèƒ½å¤Ÿæ­£ç¡®å¤„ç†æ•°ç»„ç±»å‹çš„å­èŠ‚ç‚¹ï¼Œå¹¶è·³è¿‡å…ƒæ•°æ®å±æ€§ã€‚éå†è¿‡ç¨‹ä¸­ä¼šè§¦å‘è§„åˆ™ç›‘å¬å™¨çš„ç›¸åº”æ–¹æ³•ï¼Œå®ç°äº†äº‹ä»¶é©±åŠ¨çš„è§„åˆ™åº”ç”¨æœºåˆ¶ã€‚

è§„åˆ™åº”ç”¨è¿‡ç¨‹ä¸­ï¼Œç³»ç»Ÿä¼šä¸ºæ¯ä¸ªæ¿€æ´»çš„è§„åˆ™åˆ›å»ºç›‘å¬å™¨ï¼Œå¹¶é€šè¿‡ traverse å‡½æ•°åº”ç”¨åˆ° AST ä¸Šï¼š

```typescript
// è§„åˆ™åº”ç”¨ä¸é”™è¯¯æ”¶é›†çš„æ ¸å¿ƒé€»è¾‘
async analyzeAbstractSyntaxTree(ast: AST, filePath: string, sourceCode: string) {
  try {
    for (const rule of this.rules) {
      const ruleOptions = this.getRuleOptions(rule);
      const ruleName = rule.meta.name;
      const ruleConfig = this.config?.rules?.[ruleName];

      // è§£æé”™è¯¯çº§åˆ«
      let severity: "error" | "warn" = "error";
      if (ruleConfig === "warn" ||
          (Array.isArray(ruleConfig) && ruleConfig[0] === "warn")) {
        severity = "warn";
      }

      // åˆ›å»ºè§„åˆ™ä¸Šä¸‹æ–‡å’Œç›‘å¬å™¨
      const listener = rule.create({
        report: (data) => {
          this.errors.push({
            ...data,
            filePath,
            severity,
          });
        },
        options: ruleOptions,
        getSourceCode: () => sourceCode,
      });

      // åº”ç”¨è§„åˆ™åˆ° AST
      traverse(ast, listener);
    }
  } catch (error) {
    console.error(`åˆ†æ ${filePath} çš„æŠ½è±¡è¯­æ³•æ ‘æ—¶å‡ºé”™:`, error);
  }
}
```

è¿™æ®µä»£ç éå†æ‰€æœ‰æ¿€æ´»çš„è§„åˆ™ï¼Œä¸ºæ¯ä¸ªè§„åˆ™åˆ›å»ºä¸Šä¸‹æ–‡å¯¹è±¡ï¼ˆåŒ…å« report å‡½æ•°ç”¨äºæ”¶é›†é”™è¯¯ï¼‰ï¼Œç„¶åé€šè¿‡ traverse å‡½æ•°å°†è§„åˆ™ç›‘å¬å™¨åº”ç”¨åˆ° AST ä¸Šï¼Œå®ç°ä»£ç æ£€æŸ¥ã€‚é”™è¯¯çº§åˆ«çš„è§£æè®©ç”¨æˆ·å¯ä»¥çµæ´»æ§åˆ¶é—®é¢˜çš„ä¸¥é‡ç¨‹åº¦ã€‚

##### é”™è¯¯ä¿¡æ¯ç®¡ç†

é”™è¯¯ä¿¡æ¯ç®¡ç†é‡‡ç”¨å¼‚æ­¥æœºåˆ¶ï¼š

```typescript
async getErrors(): Promise<LintError[]> {
  await this.analysisComplete;
  return this.errors;
}
```

`getErrors` æ–¹æ³•é€šè¿‡ç­‰å¾… `analysisComplete` Promise ç¡®ä¿æ‰€æœ‰å¼‚æ­¥åˆ†æä»»åŠ¡å®Œæˆï¼Œç„¶åè¿”å›é”™è¯¯åˆ—è¡¨ã€‚

#### 2.3.4 è§„åˆ™ç³»ç»Ÿæ¶æ„

è§„åˆ™ç³»ç»Ÿæ˜¯ Mini-ESLint çš„æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£å®šä¹‰ã€åŠ è½½ã€ç®¡ç†å’Œæ‰§è¡Œå„ç§ä»£ç æ£€æŸ¥è§„åˆ™ã€‚å®ƒé‡‡ç”¨æ’ä»¶åŒ–æ¶æ„ï¼Œæ”¯æŒè§„åˆ™çš„åŠ¨æ€åŠ è½½å’Œé…ç½®é©±åŠ¨çš„æ‰§è¡Œã€‚

##### è§„åˆ™æ¥å£è®¾è®¡

æ ¸å¿ƒæ¥å£å®šä¹‰ï¼š

```typescript
export interface Rule {
  meta: {
    name: string; // è§„åˆ™åç§°ï¼Œç”¨äºé…ç½®å’Œé”™è¯¯æŠ¥å‘Š
    docs: string; // è§„åˆ™æ–‡æ¡£è¯´æ˜
    schema: any; // è§„åˆ™é€‰é¡¹çš„ JSON Schema
  };
  create(ctx: RuleContext): RuleListener; // è§„åˆ™å·¥å‚å‡½æ•°
}

export interface RuleContext {
  report: (data: {
    // é”™è¯¯æŠ¥å‘Šå‡½æ•°
    node: ASTNode;
    // é”™è¯¯ä¿¡æ¯
    message: string;
    // è§„åˆ™ ID
    ruleId: string;
    line: number;
    column: number;
  }) => void;
  options?: string[]; // è§„åˆ™é…ç½®é€‰é¡¹
  getSourceCode: () => string; // è·å–æºä»£ç å‡½æ•°
}

export interface RuleListener {
  [key: string]: (node: ASTNode) => void; // AST èŠ‚ç‚¹ç›‘å¬å™¨æ˜ å°„
}
```

æˆ‘ä»¬è®¾è®¡çš„è§„åˆ™ä¸»è¦æœ‰ meta å’Œ create ä¸¤ä¸ªéƒ¨åˆ†ï¼Œmeta éƒ¨åˆ†å®šä¹‰äº†è§„åˆ™çš„å…ƒæ•°æ®ï¼Œå¦‚è§„åˆ™åç§°ã€æ–‡æ¡£è¯´æ˜å’Œé€‰é¡¹çš„ JSON Schemaã€‚create éƒ¨åˆ†æ˜¯ä¸€ä¸ªå·¥å‚å‡½æ•°ï¼Œæ ¹æ®ä¸Šä¸‹æ–‡åˆ›å»ºè§„åˆ™ç›‘å¬å™¨ï¼Œåœ¨è§„åˆ™ç›‘å¬å™¨ä¸­å®ç°å…·ä½“çš„æ£€æŸ¥é€»è¾‘ï¼Œç„¶åé€šè¿‡ ctx.report å‡½æ•°æŠ¥å‘Šé”™è¯¯ã€‚è¿™æ ·åšåˆ°å¥½å¤„æ˜¯ï¼š

1.  è§„åˆ™çš„å®šä¹‰å’Œå®ç°åˆ†ç¦»ï¼Œè§„åˆ™å®šä¹‰åªå…³æ³¨å…ƒæ•°æ®å’Œé€‰é¡¹ï¼Œè€Œå…·ä½“çš„æ£€æŸ¥é€»è¾‘åœ¨ create æ–¹æ³•ä¸­å®ç°ï¼Œç¬¦åˆå•ä¸€èŒè´£åŸåˆ™ã€‚
2.  è§„åˆ™çš„åŠ¨æ€åˆ›å»ºå’Œé…ç½®ï¼Œé€šè¿‡ create æ–¹æ³•æ ¹æ®ä¸Šä¸‹æ–‡åˆ›å»ºè§„åˆ™ç›‘å¬å™¨ï¼Œå®ç°äº†è§„åˆ™çš„åŠ¨æ€åŠ è½½å’Œé…ç½®ã€‚
3.  è§„åˆ™çš„å¯æ‰©å±•æ€§ï¼Œé€šè¿‡å®šä¹‰è§„åˆ™æ¥å£å’Œä¸Šä¸‹æ–‡å¯¹è±¡ï¼Œæ”¯æŒè§„åˆ™çš„æ‰©å±•å’Œå®šåˆ¶ã€‚
4.  è§„åˆ™çš„é”™è¯¯æŠ¥å‘Šï¼Œé€šè¿‡ ctx.report å‡½æ•°æŠ¥å‘Šé”™è¯¯ï¼Œç¡®ä¿é”™è¯¯ä¿¡æ¯æ ¼å¼ä¸€è‡´ã€‚

å…·ä½“æ¥å£è®¾è®¡åŸç†ï¼š

1.  create æ–¹æ³•é‡‡ç”¨å·¥å‚æ¨¡å¼ï¼Œæ ¹æ®ä¸Šä¸‹æ–‡åˆ›å»ºè§„åˆ™ç›‘å¬å™¨ï¼Œå®ç°äº†è§„åˆ™çš„åŠ¨æ€åˆ›å»ºå’Œé…ç½®ã€‚

```typescript
// å·¥å‚æ¨¡å¼çš„å®é™…åº”ç”¨ç¤ºä¾‹
const ruleContext = {
  report: (data) => this.errors.push(data),
  options: this.getRuleOptions(rule),
  getSourceCode: () => sourceCode,
};

// æ¯æ¬¡åˆ†æéƒ½åˆ›å»ºæ–°çš„ç›‘å¬å™¨å®ä¾‹
const listener = rule.create(ruleContext);
```

2.  RuleListener æ¥å£é€šè¿‡èŠ‚ç‚¹ç±»å‹åç§°æ˜ å°„åˆ°å¤„ç†å‡½æ•°ï¼Œå®ç°äº†å¯¹ç‰¹å®š AST èŠ‚ç‚¹çš„ç›‘å¬å’Œå¤„ç†ã€‚æˆ‘ä»¬åªéœ€è¦å¤„ç†æˆ‘ä»¬å…³æ³¨çš„èŠ‚ç‚¹ç±»å‹å³å¯ï¼Œæ¯ç§èŠ‚ç‚¹ç±»å‹çš„å¤„ç†å¯ä»¥é€»è¾‘åˆ†ç¦»ã€‚

```typescript
// äº‹ä»¶é©±åŠ¨çš„ç›‘å¬å™¨ç¤ºä¾‹
const listener: RuleListener = {
  // ç›‘å¬å˜é‡å£°æ˜èŠ‚ç‚¹
  VariableDeclarator: (node) => {
    // å¤„ç†å˜é‡å£°æ˜é€»è¾‘
  },

  // ç›‘å¬æ ‡è¯†ç¬¦èŠ‚ç‚¹
  Identifier: (node) => {
    // å¤„ç†æ ‡è¯†ç¬¦é€»è¾‘
  },

  // ç›‘å¬ç¨‹åºé€€å‡ºäº‹ä»¶
  "Program:exit": (node) => {
    // ç¨‹åºåˆ†æå®Œæˆåçš„æ¸…ç†å·¥ä½œ
  },
};
```

3.  RuleContext æä¾›è§„åˆ™æ‰§è¡Œæ‰€éœ€çš„æ‰€æœ‰ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå¦‚é”™è¯¯æŠ¥å‘Šå‡½æ•°ã€è§„åˆ™é€‰é¡¹å’Œæºä»£ç è·å–å‡½æ•°ã€‚æˆ‘ä»¬å¯ä»¥åœ¨è§„åˆ™ç›‘å¬å™¨ä¸­é€šè¿‡ ctx è®¿é—®è¿™äº›ä¿¡æ¯ï¼Œç»Ÿä¸€çš„ report å‡½æ•°ç¡®ä¿é”™è¯¯ä¿¡æ¯æ ¼å¼ä¸€è‡´ï¼Œoptions æ•°ç»„æ”¯æŒå¤æ‚çš„è§„åˆ™é…ç½®ï¼ŒgetSourceCode æ”¯æŒéœ€è¦åˆ†æåŸå§‹ä»£ç çš„é«˜çº§è§„åˆ™ã€‚

```typescript
// ä¸Šä¸‹æ–‡æ³¨å…¥çš„å®Œæ•´ç¤ºä¾‹
interface RuleContext {
  // é”™è¯¯æŠ¥å‘Šå‡½æ•° - æ ¸å¿ƒåŠŸèƒ½
  report: (data: {
    node: ASTNode; // é—®é¢˜èŠ‚ç‚¹
    message: string; // é”™è¯¯æè¿°
    ruleId: string; // è§„åˆ™æ ‡è¯†
    line: number; // è¡Œå·
    column: number; // åˆ—å·
  }) => void;

  // è§„åˆ™é…ç½®é€‰é¡¹ - çµæ´»é…ç½®
  options?: string[]; // å¦‚ ["always", "never"]

  // æºä»£ç è·å– - é«˜çº§åˆ†æ
  getSourceCode: () => string; // è·å–å®Œæ•´æºä»£ç 
}
```

##### è§„åˆ™å®ç°æ¨¡å¼åˆ†æ

æˆ‘ä»¬é€šè¿‡ä¸¤ä¸ªè§„åˆ™è®²è§£ä¸€ä¸‹æ€ä¹ˆå®ç°è§„åˆ™ï¼š

1.  Semi è§„åˆ™ï¼š

- è§„åˆ™åç§°ï¼šsemi
- è§„åˆ™æ–‡æ¡£ï¼šè¦æ±‚åœ¨è¯­å¥æœ«å°¾æ·»åŠ åˆ†å·
- è§„åˆ™é€‰é¡¹ï¼šalways æˆ– never
- è§„åˆ™å®ç°ï¼šåœ¨ create æ–¹æ³•ä¸­ç›‘å¬ Statement èŠ‚ç‚¹ï¼Œåˆ¤æ–­è¯­å¥æ˜¯å¦ä»¥åˆ†å·ç»“å°¾ï¼Œæ ¹æ®é€‰é¡¹åˆ¤æ–­æ˜¯å¦æŠ¥å‘Šé”™è¯¯ã€‚

  åˆ†æä¸€ä¸‹ä¸Šé¢çš„ä»‹ç»ï¼Œæˆ‘ä»¬éœ€è¦åœ¨å¯¹åº”çš„èŠ‚ç‚¹åšåˆ¤æ–­ï¼Œè¿åè§„åˆ™çš„æ—¶å€™ç«‹å³è¿”å›ï¼Œä»£ç å¦‚ä¸‹ï¼š

```typescript
export default {
  meta: {
    name: "semi",
    docs: "Require or disallow semicolons instead of ASI",
    schema: {
      enum: ["always", "never"],
      default: "always",
    },
  },
  create(ctx: RuleContext): RuleListener {
    const defaultConfig = ctx.options?.[0] || "always";
    const isSemicolonRequired = defaultConfig === "always";
    const sourceCode = ctx.getSourceCode();
    const types = [
      "VariableDeclaration", // å˜é‡å£°æ˜: const a = 1;
      "ExpressionStatement", // è¡¨è¾¾å¼è¯­å¥: console.log();
      "ReturnStatement", // è¿”å›è¯­å¥: return value;
      "ThrowStatement", // æŠ›å‡ºè¯­å¥: throw new Error();
      "BreakStatement", // ä¸­æ–­è¯­å¥: break;
      "ContinueStatement", // ç»§ç»­è¯­å¥: continue;
      "ImportDeclaration", // å¯¼å…¥è¯­å¥: import { a } from 'b';
      "ExportNamedDeclaration", // å‘½åå¯¼å‡º: export { a };
      "ExportDefaultDeclaration", // é»˜è®¤å¯¼å‡º: export default a;
      "ExportAllDeclaration", // å…¨éƒ¨å¯¼å‡º: export * from 'module';
    ];

    // æ£€æŸ¥åˆ†å·çš„é€šç”¨å‡½æ•°
    function checkSemicolon(node: ASTNode) {
      const lastToken = sourceCode.charAt(node.end - 1);
      const hasSemicolon = lastToken === ";";

      const { line, endColumn } = getNodeLocation(node);
      if (isSemicolonRequired && !hasSemicolon) {
        // ç¼ºå°‘åˆ†å·ï¼šæŠ¥å‘Šåº”è¯¥æ·»åŠ åˆ†å·çš„ä½ç½®ï¼ˆè¯­å¥ç»“æŸä½ç½®ï¼‰
        ctx.report({
          node: node,
          message: `Missing semicolon.`,
          ruleId: "semi",
          line: line,
          column: endColumn,
        });
      } else if (!isSemicolonRequired && hasSemicolon) {
        // å¤šä½™åˆ†å·ï¼šæŠ¥å‘Šåˆ†å·æœ¬èº«çš„ä½ç½®
        ctx.report({
          node: node,
          message: `Extra semicolon.`,
          ruleId: "semi",
          line: line,
          column: endColumn,
        });
      }
    }

    // åŠ¨æ€ç”Ÿæˆç›‘å¬å™¨å¯¹è±¡
    const listeners: RuleListener = {};
    types.forEach((type) => {
      listeners[type] = checkSemicolon;
    });
    return listeners;
  },
};
```

åœ¨ create å‡½æ•°çš„å®ç°ä¸­ï¼Œä»£ç é¦–å…ˆè§£æé…ç½®é€‰é¡¹æ¥ç¡®å®šæ˜¯å¦éœ€è¦åˆ†å·ï¼Œç„¶åå®šä¹‰äº†ä¸€ä¸ªä¸åŒ AST èŠ‚ç‚¹ç±»å‹çš„æ•°ç»„ï¼ˆå¦‚å˜é‡å£°æ˜ã€è¡¨è¾¾å¼è¯­å¥ã€è¿”å›è¯­å¥ç­‰ï¼‰ï¼Œè¿™äº›éƒ½æ˜¯éœ€è¦åˆ†å·çš„è¯­å¥ç±»å‹ã€‚æ ¸å¿ƒçš„ checkSemicolon å‡½æ•°è´Ÿè´£æ£€æŸ¥æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦ç¬¦åˆåˆ†å·è§„åˆ™ï¼šå®ƒé€šè¿‡æ£€æŸ¥èŠ‚ç‚¹æœ«å°¾å­—ç¬¦æ¥åˆ¤æ–­æ˜¯å¦å­˜åœ¨åˆ†å·ï¼Œç„¶åæ ¹æ®é…ç½®è¦æ±‚æŠ¥å‘Šç›¸åº”çš„é”™è¯¯ï¼ˆç¼ºå°‘åˆ†å·æˆ–å¤šä½™åˆ†å·ï¼‰ã€‚æœ€åï¼Œä»£ç åŠ¨æ€ç”Ÿæˆç›‘å¬å™¨å¯¹è±¡ï¼Œä¸ºæ¯ç§èŠ‚ç‚¹ç±»å‹ç»‘å®šç›¸åŒçš„æ£€æŸ¥å‡½æ•°ï¼Œå®ç°äº†é«˜æ•ˆçš„äº‹ä»¶é©±åŠ¨æ£€æŸ¥æœºåˆ¶ã€‚è¿™ç§è®¾è®¡ä½“ç°äº† ESLint è§„åˆ™ç³»ç»Ÿçš„æ ¸å¿ƒç‰¹ç‚¹ï¼šé…ç½®é©±åŠ¨ã€äº‹ä»¶ç›‘å¬å’Œç²¾ç¡®é”™è¯¯æŠ¥å‘Šã€‚

2.  no-unused-vars è§„åˆ™

- è§„åˆ™åç§°ï¼šno-unused-vars
- è§„åˆ™æ–‡æ¡£ï¼šä¸å…è®¸å®šä¹‰æœªä½¿ç”¨çš„å˜é‡
- è§„åˆ™é€‰é¡¹ï¼šæ— 

  åŒæ ·åˆ†æä¸€ä¸‹è¿™ä¸ªè§„åˆ™ï¼Œæˆ‘ä»¬éœ€è¦è®°å½•æ‰€æœ‰å£°æ˜çš„å˜é‡ï¼Œåœ¨ Identifier èŠ‚ç‚¹ä¸­è®°å½•æ‰€æœ‰ä½¿ç”¨çš„å˜é‡ï¼Œæœ€åéå†æ‰€æœ‰å£°æ˜çš„å˜é‡ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰æœªè¢«ä½¿ç”¨çš„å˜é‡ã€‚ä»£ç å¦‚ä¸‹ï¼š

```typescript
export default {
  meta: {
    name: "no-unused-vars",
    docs: "disallow unused variables",
    schema: [],
  },
  create(ctx: RuleContext): RuleListener {
    // å­˜å‚¨æ‰€æœ‰å£°æ˜çš„å˜é‡
    const declared = new Set<string>();
    // å­˜å‚¨æ‰€æœ‰ä½¿ç”¨çš„å˜é‡
    const used = new Set<string>();
    // å­˜å‚¨å˜é‡å£°æ˜èŠ‚ç‚¹ä¿¡æ¯ï¼Œç”¨äºæŠ¥å‘Šé”™è¯¯æ—¶å®šä½
    const declaredInfo = new Map<string, ASTNode>();
    // ä¸´æ—¶å­˜å‚¨æ­£åœ¨å¤„ç†çš„å˜é‡å£°æ˜
    const declaredUsed = new Set<string>();
    // å­˜å‚¨æ‰€æœ‰å¯¼å‡ºçš„å˜é‡
    const exportedVars = new Set<string>();

    return {
      // å¤„ç†å˜é‡å£°æ˜
      VariableDeclarator(node) {
        declared.add(node.id.name);
        declaredUsed.add(node.id.name);
        declaredInfo.set(node.id.name, node);
      },
      // å¤„ç†æ ‡è¯†ç¬¦ï¼ˆå˜é‡ä½¿ç”¨ï¼‰
      Identifier(node) {
        if (!declaredUsed.has(node.name)) {
          used.add(node.name);
        }
      },
      // å¤„ç†å¯¼å‡ºå£°æ˜
      ExportNamedDeclaration(node) {
        // å¤„ç† export const/let/var å£°æ˜
        if (
          node.declaration &&
          node.declaration.type === "VariableDeclaration"
        ) {
          const declarations = node.declaration.declarations;
          for (const decl of declarations) {
            if (decl.id && decl.id.type === "Identifier") {
              // å°†å¯¼å‡ºçš„å˜é‡æ·»åŠ åˆ°å·²ä½¿ç”¨é›†åˆä¸­
              used.add(decl.id.name);
              exportedVars.add(decl.id.name);
            }
          }
        }
      },

      // å˜é‡å£°æ˜å¤„ç†å®Œæˆåçš„æ¸…ç†
      "VariableDeclarator:exit"(node) {
        if (node.id && node.id.type === "Identifier") {
          declaredUsed.delete(node.id.name);
        }
      },

      // ç¨‹åºç»“æŸæ—¶æ£€æŸ¥æœªä½¿ç”¨çš„å˜é‡
      "Program:exit"() {
        for (const name of declared) {
          const node = declaredInfo.get(name)!;
          const { line, startColumn } = getNodeLocation(node);
          if (!used.has(name)) {
            ctx.report({
              node: declaredInfo.get(name)!,
              message: `'${name}' is declared but never used`,
              ruleId: "no-unused-vars",
              line,
              column: startColumn,
            });
          }
        }
      },
    };
  },
};
```

åœ¨ create å‡½æ•°çš„å®ç°ä¸­ï¼Œä»£ç ä½¿ç”¨äº†äº”ä¸ªå…³é”®çš„æ•°æ®ç»“æ„ï¼šdeclared Set å­˜å‚¨æ‰€æœ‰å£°æ˜çš„å˜é‡åï¼Œused Set å­˜å‚¨æ‰€æœ‰è¢«ä½¿ç”¨çš„å˜é‡åï¼ŒdeclaredInfo Map å­˜å‚¨å˜é‡å£°æ˜èŠ‚ç‚¹ä¿¡æ¯ç”¨äºé”™è¯¯å®šä½ï¼ŒdeclaredUsed Set ä¸´æ—¶å­˜å‚¨æ­£åœ¨å¤„ç†çš„å˜é‡å£°æ˜ï¼Œä»¥åŠ exportedVars Set å­˜å‚¨å¯¼å‡ºçš„å˜é‡ã€‚è§„åˆ™é€šè¿‡ç›‘å¬å¤šç§ AST èŠ‚ç‚¹äº‹ä»¶æ¥å®ç°æ£€æµ‹é€»è¾‘ï¼šVariableDeclarator å¤„ç†å˜é‡å£°æ˜ï¼ŒIdentifier å¤„ç†å˜é‡ä½¿ç”¨ï¼ŒExportNamedDeclaration å¤„ç†å¯¼å‡ºå£°æ˜ï¼ˆå°†å¯¼å‡ºçš„å˜é‡æ ‡è®°ä¸ºå·²ä½¿ç”¨ï¼‰ï¼ŒVariableDeclarator:exit è¿›è¡Œæ¸…ç†å·¥ä½œï¼Œæœ€ååœ¨ Program:exit äº‹ä»¶ä¸­éå†æ‰€æœ‰å£°æ˜çš„å˜é‡ï¼Œå¯¹äºæœªè¢«ä½¿ç”¨çš„å˜é‡æŠ¥å‘Šé”™è¯¯ã€‚è¿™ç§è®¾è®¡ä½“ç°äº†çŠ¶æ€ç®¡ç†å‹è§„åˆ™çš„ç‰¹ç‚¹ï¼šéœ€è¦åœ¨æ•´ä¸ª AST éå†è¿‡ç¨‹ä¸­ç»´æŠ¤çŠ¶æ€ï¼Œå¹¶åœ¨æœ€åè¿›è¡Œç»Ÿä¸€æ£€æŸ¥å’ŒæŠ¥å‘Šã€‚

##### è§„åˆ™å®ç°æŒ‡å—

###### ç¬¬ä¸€æ­¥ï¼šç¡®å®šè§„åˆ™ç±»å‹

å³æ—¶æ£€æµ‹å‹è§„åˆ™ï¼š

- é€‚ç”¨äºè¯­æ³•æ£€æŸ¥ã€æ ¼å¼æ£€æŸ¥

- åœ¨éå†åˆ°èŠ‚ç‚¹æ—¶ç«‹å³æ£€æŸ¥

- æ— éœ€ç»´æŠ¤å¤æ‚çŠ¶æ€

- ç¤ºä¾‹ï¼šåˆ†å·æ£€æŸ¥ã€ç¼©è¿›æ£€æŸ¥
  çŠ¶æ€ç®¡ç†å‹è§„åˆ™ï¼š

- é€‚ç”¨äºè¯­ä¹‰åˆ†æã€ä¾èµ–å…³ç³»æ£€æŸ¥

- éœ€è¦æ”¶é›†ä¿¡æ¯åç»Ÿä¸€åˆ†æ

- ä½¿ç”¨ Program:exit è¿›è¡Œæœ€ç»ˆæ£€æŸ¥

- ç¤ºä¾‹ï¼šæœªä½¿ç”¨å˜é‡ã€å¾ªç¯ä¾èµ–

###### ç¬¬äºŒæ­¥ï¼šè®¾è®¡è§„åˆ™ç»“æ„

```typescript
export default {
  meta: {
    name: "your-rule-name",
    docs: "è§„åˆ™æè¿°",
    schema: [], // æˆ–å…·ä½“çš„é…ç½®æ¨¡å¼
  },
  create(ctx: RuleContext): RuleListener {
    // 1. è§£æé…ç½®é€‰é¡¹
    const options = ctx.options || [];

    // 2. åˆå§‹åŒ–çŠ¶æ€ï¼ˆå¦‚æœéœ€è¦ï¼‰
    const state = new Map();

    // 3. å®šä¹‰æ£€æŸ¥å‡½æ•°
    function checkNode(node: ASTNode) {
      // æ£€æŸ¥é€»è¾‘
    }

    // 4. è¿”å›ç›‘å¬å™¨
    return {
      NodeType: checkNode,
      "Program:exit": () => {
        /* æœ€ç»ˆæ£€æŸ¥ */
      },
    };
  },
};
```

###### ç¬¬ä¸‰æ­¥ï¼šé€‰æ‹©ç›‘å¬çš„ AST èŠ‚ç‚¹

å¸¸ç”¨èŠ‚ç‚¹ç±»å‹ï¼š

- VariableDeclarator : å˜é‡å£°æ˜
- Identifier : æ ‡è¯†ç¬¦
- FunctionDeclaration : å‡½æ•°å£°æ˜
- CallExpression : å‡½æ•°è°ƒç”¨
- Program:exit : ç¨‹åºç»“æŸ

###### ç¬¬å››æ­¥ï¼šå®ç°æ£€æŸ¥é€»è¾‘

å…³é”®è¦ç´ ï¼š

1.  å‡†ç¡®çš„é”™è¯¯å®šä½ ï¼šä½¿ç”¨ getNodeLocation() è·å–ç²¾ç¡®ä½ç½®
2.  æ¸…æ™°çš„é”™è¯¯æ¶ˆæ¯ ï¼šæä¾›æœ‰æ„ä¹‰çš„é”™è¯¯æè¿°
3.  æ€§èƒ½ä¼˜åŒ– ï¼šé¿å…é‡å¤è®¡ç®—ï¼Œåˆç†ä½¿ç”¨æ•°æ®ç»“æ„
4.  è¾¹ç•Œæƒ…å†µå¤„ç† ï¼šè€ƒè™‘å„ç§ç‰¹æ®Šæƒ…å†µ

###### ç¬¬äº”æ­¥ï¼šé”™è¯¯æŠ¥å‘Š

```typescript
ctx.report({
  node: problemNode, // é—®é¢˜èŠ‚ç‚¹
  message: "é”™è¯¯æè¿°", // æ¸…æ™°çš„é”™è¯¯æ¶ˆæ¯
  ruleId: "rule-name", // è§„åˆ™æ ‡è¯†
  line: lineNumber, // è¡Œå·
  column: columnNumber, // åˆ—å·
});
```

#### 2.3.5 æ ¼å¼åŒ–å™¨ä¸è¾“å‡º

æ ¼å¼åŒ–å™¨ä¸è¾“å‡ºç³»ç»Ÿæ˜¯ mini-eslint ç”¨æˆ·ä½“éªŒçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œè´Ÿè´£å°†æ£€æµ‹åˆ°çš„é”™è¯¯ä¿¡æ¯ä»¥å‹å¥½ã€æ¸…æ™°çš„æ–¹å¼å‘ˆç°ç»™ç”¨æˆ·ã€‚

##### æ ¼å¼åŒ–å™¨æ¶æ„è®¾è®¡

**1. æ ¼å¼åŒ–å™¨æ¥å£**

æ ¼å¼åŒ–å™¨é‡‡ç”¨å‡½æ•°å¼è®¾è®¡ï¼Œæ¥æ”¶ `LintError[]` æ•°ç»„ä½œä¸ºè¾“å…¥ï¼š

```typescript
export function stylish(errors: LintError[]): void {
  // æ ¼å¼åŒ–é€»è¾‘
}
```

**2. æ•°æ®ç»“æ„**

æ ¼å¼åŒ–å™¨å¤„ç†çš„æ ¸å¿ƒæ•°æ®ç»“æ„æ˜¯ `LintError`ï¼š

```typescript
export interface LintError {
  node: ASTNode; // AST èŠ‚ç‚¹ä¿¡æ¯
  message: string; // é”™è¯¯æè¿°
  ruleId: string; // è§„åˆ™æ ‡è¯†
  filePath: string; // æ–‡ä»¶è·¯å¾„
  severity?: "error" | "warn"; // é”™è¯¯çº§åˆ«
  line: number; // è¡Œå·
  column: number; // åˆ—å·
}
```

##### Stylish æ ¼å¼åŒ–å™¨å®ç°

**1. é”™è¯¯åˆ†ç»„ä¸æ’åº**

```typescript
// æŒ‰æ–‡ä»¶åˆ†ç»„é”™è¯¯
const errorsByFile = errors.reduce<Record<string, LintError[]>>(
  (acc, error) => {
    if (!acc[error.filePath]) {
      acc[error.filePath] = [];
    }
    acc[error.filePath].push(error);
    return acc;
  },
  {}
);

// å¯¹æ–‡ä»¶ä¸­çš„é”™è¯¯æŒ‰è¡Œå·æ’åº
fileErrors.sort((a, b) => a.line - b.line || a.column - b.column);
```

**2. å½©è‰²è¾“å‡º**

ä½¿ç”¨ `chalk` åº“å®ç°å½©è‰²è¾“å‡ºï¼Œæå‡ç”¨æˆ·ä½“éªŒï¼š

```typescript
// æ ¹æ®é”™è¯¯çº§åˆ«è®¾ç½®ä¸åŒçš„é¢œè‰²
const severityColor = severity === "error" ? chalk.red : chalk.yellow;
const severityText = severity === "error" ? "error" : "warning";

console.log(
  `  ${location}  ` +
    `${severityColor(severityText)}  ` +
    `${error.message}  ` +
    `${chalk.gray(ruleName)}`
);
```

**3. ç»Ÿè®¡ä¿¡æ¯å±•ç¤º**

```typescript
// ç»Ÿè®¡é”™è¯¯å’Œè­¦å‘Šçš„æ•°é‡
let errorCount = 0;
let warningCount = 0;

// æ™ºèƒ½å¤æ•°å¤„ç†
function pluralize(word: string, count: number): string {
  return count === 1 ? word : `${word}s`;
}

// æ˜¾ç¤ºæ€»ç»“ä¿¡æ¯
const total = errorCount + warningCount;
const summary = [
  `âœ– ${total} ${pluralize("problem", total)}`,
  `(${errorCount} ${pluralize("error", errorCount)},`,
  `${warningCount} ${pluralize("warning", warningCount)})`,
].join(" ");
```

##### è¾“å‡ºæ ¼å¼è§„èŒƒ

**1. æ–‡ä»¶çº§åˆ«è¾“å‡º**

![image](img/1-4.png)

**2. æ— é”™è¯¯è¾“å‡º**

![image](img/1-5.png)

**3. é¢œè‰²ç¼–ç **

- ğŸ”´ **é”™è¯¯ (error)**: çº¢è‰²æ˜¾ç¤º
- ğŸŸ¡ **è­¦å‘Š (warning)**: é»„è‰²æ˜¾ç¤º
- ğŸŸ¢ **æˆåŠŸ**: ç»¿è‰²æ˜¾ç¤º
- ğŸ”˜ **è§„åˆ™å**: ç°è‰²æ˜¾ç¤º

## 3. æµ‹è¯•ä½“ç³»å»ºè®¾

### 3.1 æµ‹è¯•æ¡†æ¶é€‰å‹ä¸é…ç½®

#### 3.1.1 æµ‹è¯•æ¡†æ¶é€‰æ‹©

Vitest æ¡†æ¶ä¼˜åŠ¿

Mini-ESLint é¡¹ç›®é€‰æ‹© Vitest ä½œä¸ºæµ‹è¯•æ¡†æ¶ï¼Œä¸»è¦åŸºäºä»¥ä¸‹è€ƒè™‘ï¼š

- ç°ä»£åŒ–è®¾è®¡ ï¼šåŸç”Ÿæ”¯æŒ TypeScript å’Œ ES æ¨¡å—
- é«˜æ€§èƒ½ ï¼šåŸºäº Vite æ„å»ºï¼Œå¯åŠ¨é€Ÿåº¦å¿«ï¼Œçƒ­æ›´æ–°æ•ˆç‡é«˜
- å…¼å®¹æ€§å¼º ï¼šAPI ä¸ Jest é«˜åº¦å…¼å®¹ï¼Œè¿ç§»æˆæœ¬ä½
- å†…ç½®åŠŸèƒ½ä¸°å¯Œ ï¼šæ— éœ€é¢å¤–é…ç½®å³å¯æ”¯æŒä»£ç è¦†ç›–ç‡ã€å¿«ç…§æµ‹è¯•ç­‰

#### 3.1.2 æµ‹è¯•é…ç½®

package.json æµ‹è¯•è„šæœ¬é…ç½®

```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  "devDependencies": {
    "vitest": "^3.2.4",
    "@types/node": "^24.1.0"
  }
}
```

### 3.2 æµ‹è¯•æ¶æ„è®¾è®¡

#### 3.2.1 æµ‹è¯•åˆ†å±‚ç­–ç•¥

1.  å•å…ƒæµ‹è¯•ï¼ˆUnit Testsï¼‰

- è§„åˆ™æµ‹è¯• ï¼šæ¯ä¸ª ESLint è§„åˆ™çš„ç‹¬ç«‹æµ‹è¯•
- å·¥å…·å‡½æ•°æµ‹è¯• ï¼šAST éå†ã€é…ç½®åˆå¹¶ç­‰å·¥å…·å‡½æ•°
- ç»„ä»¶æµ‹è¯• ï¼šLinter ç±»ã€CLI æ¨¡å—ç­‰æ ¸å¿ƒç»„ä»¶

2.  é›†æˆæµ‹è¯•ï¼ˆIntegration Testsï¼‰

- ç«¯åˆ°ç«¯æµç¨‹æµ‹è¯• ï¼šä»æ–‡ä»¶æ‰«æåˆ°é”™è¯¯è¾“å‡ºçš„å®Œæ•´æµç¨‹
- é…ç½®ç³»ç»Ÿæµ‹è¯• ï¼šé…ç½®æ–‡ä»¶åŠ è½½ã€è§„åˆ™åº”ç”¨ç­‰é›†æˆåœºæ™¯
- å¤šæ–‡ä»¶å¤„ç†æµ‹è¯• ï¼šæ‰¹é‡æ–‡ä»¶åˆ†æå’Œå¹¶è¡Œå¤„ç†

### 3.3 æ ¸å¿ƒæµ‹è¯•å®ç°

#### 3.3.1 Linter å¼•æ“æµ‹è¯•

æµ‹è¯•è¾…åŠ©å‡½æ•°è®¾è®¡

```typescript
// åˆ›å»ºä¸´æ—¶æµ‹è¯•æ–‡ä»¶
function createTempFile(fileName: string, content: string): string {
  const tempDir = path.join(__dirname, "temp");
  if (!fs.existsSync(tempDir)) {
    fs.mkdirSync(tempDir, { recursive: true });
  }
  const filePath = path.join(tempDir, fileName);
  fs.writeFileSync(filePath, content, "utf-8");
  return filePath;
}

// æ¸…ç†ä¸´æ—¶æ–‡ä»¶
function cleanupTempFiles() {
  const tempDir = path.join(__dirname, "temp");
  if (fs.existsSync(tempDir)) {
    fs.rmSync(tempDir, { recursive: true, force: true });
  }
}

// åˆ›å»ºä¸´æ—¶é…ç½®æ–‡ä»¶
function createTempConfig(config: any): string {
  const configPath = path.join(__dirname, "temp", ".minlintrc.json");
  fs.writeFileSync(configPath, JSON.stringify(config, null, 2), "utf-8");
  return configPath;
}
```

æµ‹è¯•è¦†ç›–èŒƒå›´

```typescript
describe("Linterç±»æµ‹è¯•", () => {
  beforeEach(() => {
    cleanupTempFiles();
  });

  afterEach(() => {
    cleanupTempFiles();
  });

  describe("æ„é€ å‡½æ•°å’Œåˆå§‹åŒ–", () => {
    it("åº”è¯¥æ­£ç¡®åˆå§‹åŒ–Linterå®ä¾‹", async () => {
      const testFile = createTempFile("test.js", "const a = 1;");
      const linter = new Linter({ files: [testFile] });

      expect(linter).toBeInstanceOf(Linter);

      const errors = await linter.getErrors();
      expect(Array.isArray(errors)).toBe(true);
    });

    it("åº”è¯¥ä½¿ç”¨é»˜è®¤é…ç½®å½“æ²¡æœ‰æä¾›é…ç½®æ–‡ä»¶æ—¶", async () => {
      const testFile = createTempFile("test.js", "const a = 1");
      const linter = new Linter({ files: [testFile] });

      const errors = await linter.getErrors();
      // é»˜è®¤é…ç½®åŒ…å«semiè§„åˆ™ï¼Œæ£€æµ‹ç¼ºå°‘åˆ†å·
      expect(errors.some((error) => error.ruleId === "semi")).toBe(true);
    });

    it("åº”è¯¥æ­£ç¡®åŠ è½½JSONé…ç½®æ–‡ä»¶", async () => {
      const testFile = createTempFile("test.js", "const a = 1");
      const config = {
        rules: {
          semi: "off",
          "no-unused-vars": "error",
        },
      };
      const configFile = createTempConfig(config);

      const linter = new Linter({ files: [testFile], configFile });
      const errors = await linter.getErrors();

      // semiè§„åˆ™å…³é—­ï¼Œæ— åˆ†å·é”™è¯¯
      expect(errors.some((error) => error.ruleId === "semi")).toBe(false);
      // æœ‰æœªä½¿ç”¨å˜é‡é”™è¯¯
      expect(errors.some((error) => error.ruleId === "no-unused-vars")).toBe(
        true
      );
    });

    it("åº”è¯¥åœ¨é…ç½®æ–‡ä»¶ä¸å­˜åœ¨æ—¶ä½¿ç”¨é»˜è®¤é…ç½®", async () => {
      const testFile = createTempFile("test.js", "const a = 1");
      const nonExistentConfig = path.join(__dirname, "nonexistent.json");

      const linter = new Linter({
        files: [testFile],
        configFile: nonExistentConfig,
      });
      const errors = await linter.getErrors();

      expect(Array.isArray(errors)).toBe(true);
    });
  });

  describe("æ–‡ä»¶æ‰«æå’Œè§£æ", () => {
    it("åº”è¯¥æ­£ç¡®æ‰«æå•ä¸ªJavaScriptæ–‡ä»¶", async () => {
      const testFile = createTempFile("test.js", "const a = 1");
      const linter = new Linter({ files: [testFile] });

      const errors = await linter.getErrors();
      expect(errors.length).toBeGreaterThan(0);
      // æ£€æŸ¥æ–‡ä»¶è·¯å¾„
      expect(errors[0].filePath).toContain("test.js");
      expect(path.basename(errors[0].filePath)).toBe(path.basename(testFile));
    });

    // è·¯å¾„æ ‡å‡†åŒ–è¾…åŠ©å‡½æ•°
    function normalizeFilePath(filePath: string): string {
      return path.resolve(filePath).replace(/\\/g, "/");
    }

    function containsFile(filePaths: string[], targetFile: string): boolean {
      const normalizedTarget = normalizeFilePath(targetFile);
      return filePaths.some((filePath) => {
        const normalizedPath = normalizeFilePath(filePath);
        return (
          normalizedPath.includes(path.basename(targetFile)) ||
          normalizedPath === normalizedTarget
        );
      });
    }

    it("åº”è¯¥æ­£ç¡®æ‰«æå¤šä¸ªæ–‡ä»¶", async () => {
      const testFile1 = createTempFile("test1.js", "const a = 1");
      const testFile2 = createTempFile("test2.js", "const b = 2");

      const linter = new Linter({ files: [testFile1, testFile2] });
      const errors = await linter.getErrors();

      const filePaths = errors.map((error) => error.filePath);
      expect(containsFile(filePaths, testFile1)).toBe(true);
      expect(containsFile(filePaths, testFile2)).toBe(true);
    });

    it("åº”è¯¥æ­£ç¡®å¤„ç†globæ¨¡å¼", async () => {
      createTempFile("glob1.js", "const a = 1");
      createTempFile("glob2.js", "const b = 2");

      // ä½¿ç”¨ç»å¯¹è·¯å¾„æ„å»ºglobæ¨¡å¼
      const tempDir = path.join(__dirname, "temp");
      const globPattern = path.join(tempDir, "*.js").replace(/\\/g, "/");

      const linter = new Linter({ files: [globPattern] });
      const errors = await linter.getErrors();

      // éªŒè¯æ‰¾åˆ°äº†ä¸¤ä¸ªæ–‡ä»¶çš„é”™è¯¯
      const uniqueFiles = [
        ...new Set(errors.map((error) => path.basename(error.filePath))),
      ];
      expect(uniqueFiles).toContain("glob1.js");
      expect(uniqueFiles).toContain("glob2.js");
      expect(errors.length).toBeGreaterThan(0);
    });

    it("åº”è¯¥æ­£ç¡®å¤„ç†JSXæ–‡ä»¶", async () => {
      const jsxContent = `
        import React from 'react';
        const Component = () => <div>Hello</div>
        export default Component;
      `;
      const testFile = createTempFile("test.jsx", jsxContent);

      const linter = new Linter({ files: [testFile] });
      const errors = await linter.getErrors();

      // èƒ½å¤Ÿè§£æJSXæ–‡ä»¶
      expect(Array.isArray(errors)).toBe(true);
    });

    it("åº”è¯¥æ­£ç¡®å¤„ç†TypeScriptæ–‡ä»¶", async () => {
      const tsContent = `
        interface User {
          name: string;
          age: number;
        }
        const user: User = { name: 'John', age: 30 }
      `;
      const testFile = createTempFile("test.ts", tsContent);

      const linter = new Linter({ files: [testFile] });
      const errors = await linter.getErrors();

      expect(Array.isArray(errors)).toBe(true);
    });

    it("åº”è¯¥æ­£ç¡®å¤„ç†è¯­æ³•é”™è¯¯", async () => {
      const invalidCode = "const a = {";
      const testFile = createTempFile("invalid.js", invalidCode);

      const linter = new Linter({ files: [testFile] });

      // è¯­æ³•é”™è¯¯ä¸åº”å¯¼è‡´ç¨‹åºå´©æºƒ
      await expect(linter.getErrors()).resolves.toBeDefined();
    });
  });

  describe("è§„åˆ™åº”ç”¨å’Œé”™è¯¯æ£€æµ‹", () => {
    it("åº”è¯¥æ­£ç¡®è®¾ç½®é”™è¯¯ä¸¥é‡çº§åˆ«", async () => {
      const testFile = createTempFile("test.js", "const a = 1");
      const config = {
        rules: {
          semi: "warn",
          "no-unused-vars": "error",
        },
      };
      const configFile = createTempConfig(config);

      const linter = new Linter({ files: [testFile], configFile });
      const errors = await linter.getErrors();

      const semiError = errors.find((error) => error.ruleId === "semi");
      const unusedVarError = errors.find(
        (error) => error.ruleId === "no-unused-vars"
      );

      expect(semiError?.severity).toBe("warn");
      expect(unusedVarError?.severity).toBe("error");
    });

    it("åº”è¯¥æ­£ç¡®å¤„ç†å…³é—­çš„è§„åˆ™", async () => {
      const testFile = createTempFile("test.js", "const a = 1");
      const config = {
        rules: {
          semi: "off",
          "no-unused-vars": "off",
        },
      };
      const configFile = createTempConfig(config);

      const linter = new Linter({ files: [testFile], configFile });
      const errors = await linter.getErrors();

      expect(errors.length).toBe(0);
    });
  });

  describe("é”™è¯¯ä¿¡æ¯æ ¼å¼", () => {
    it("åº”è¯¥åŒ…å«æ­£ç¡®çš„é”™è¯¯ä¿¡æ¯æ ¼å¼", async () => {
      const testFile = createTempFile("test.js", "const a = 1");
      const linter = new Linter({ files: [testFile] });

      const errors = await linter.getErrors();
      expect(errors.length).toBeGreaterThan(0);

      const error = errors[0];
      expect(error).toHaveProperty("node");
      expect(error).toHaveProperty("message");
      expect(error).toHaveProperty("ruleId");
      expect(error).toHaveProperty("filePath");
      expect(error).toHaveProperty("line");
      expect(error).toHaveProperty("column");
      expect(error).toHaveProperty("severity");

      expect(typeof error.message).toBe("string");
      expect(typeof error.ruleId).toBe("string");
      expect(typeof error.filePath).toBe("string");
      expect(typeof error.line).toBe("number");
      expect(typeof error.column).toBe("number");
      expect(["error", "warn"]).toContain(error.severity);
    });

    it("åº”è¯¥åŒ…å«æ­£ç¡®çš„ä½ç½®ä¿¡æ¯", async () => {
      const testFile = createTempFile("test.js", "const a = 1");
      const linter = new Linter({ files: [testFile] });

      const errors = await linter.getErrors();
      const error = errors[0];

      expect(error.line).toBeGreaterThan(0);
      expect(error.column).toBeGreaterThanOrEqual(0);
    });
  });

  describe("å¼‚æ­¥å¤„ç†", () => {
    it("åº”è¯¥æ­£ç¡®å¤„ç†å¼‚æ­¥æ–‡ä»¶è§£æ", async () => {
      const testFiles = [
        createTempFile("test1.js", "const a = 1"),
        createTempFile("test2.js", "const b = 2"),
        createTempFile("test3.js", "const c = 3"),
      ];

      const linter = new Linter({ files: testFiles });
      const errors = await linter.getErrors();

      // å¤„ç†æ‰€æœ‰æ–‡ä»¶
      const uniqueFiles = [...new Set(errors.map((error) => error.filePath))];
      expect(uniqueFiles.length).toBe(3);
    });

    it("getErrorsæ–¹æ³•åº”è¯¥ç­‰å¾…åˆ†æå®Œæˆ", async () => {
      const testFile = createTempFile("test.js", "const a = 1");
      const linter = new Linter({ files: [testFile] });

      // ç«‹å³è°ƒç”¨getErrorsï¼Œç­‰å¾…åˆ†æå®Œæˆ
      const errors = await linter.getErrors();
      expect(Array.isArray(errors)).toBe(true);
    });
  });

  describe("è¾¹ç•Œæƒ…å†µ", () => {
    it("åº”è¯¥å¤„ç†ç©ºæ–‡ä»¶", async () => {
      const testFile = createTempFile("empty.js", "");
      const linter = new Linter({ files: [testFile] });

      const errors = await linter.getErrors();
      expect(Array.isArray(errors)).toBe(true);
    });

    it("åº”è¯¥å¤„ç†åªæœ‰æ³¨é‡Šçš„æ–‡ä»¶", async () => {
      const testFile = createTempFile(
        "comments.js",
        "// This is a comment\n/* Another comment */"
      );
      const linter = new Linter({ files: [testFile] });

      const errors = await linter.getErrors();
      expect(Array.isArray(errors)).toBe(true);
    });

    it("åº”è¯¥å¤„ç†ä¸å­˜åœ¨çš„æ–‡ä»¶æ¨¡å¼", async () => {
      const nonExistentPattern = path.join(__dirname, "nonexistent", "*.js");
      const linter = new Linter({ files: [nonExistentPattern] });

      const errors = await linter.getErrors();
      expect(Array.isArray(errors)).toBe(true);
      expect(errors.length).toBe(0);
    });

    it("åº”è¯¥å¤„ç†å¤æ‚çš„ä»£ç ç»“æ„", async () => {
      const complexCode = `
        function fibonacci(n) {
          if (n <= 1) return n
          return fibonacci(n - 1) + fibonacci(n - 2)
        }
        
        class Calculator {
          constructor() {
            this.result = 0
          }
          
          add(a, b) {
            return a + b
          }
        }
        
        const calc = new Calculator()
        const fib5 = fibonacci(5)
        console.log(calc.add(fib5, 10))
      `;

      const testFile = createTempFile("complex.js", complexCode);
      const linter = new Linter({ files: [testFile] });

      const errors = await linter.getErrors();
      expect(Array.isArray(errors)).toBe(true);
    });
  });
});
```

#### 3.3.2 è§„åˆ™ç³»ç»Ÿæµ‹è¯•

æµ‹è¯•è¾…åŠ©å‡½æ•°è®¾è®¡

```typescript
// è¾…åŠ©å‡½æ•°ï¼šè§£æä»£ç ç”ŸæˆAST
function parseCode(code: string): AST {
  return espree.parse(code, {
    ecmaVersion: "latest",
    sourceType: "module",
    loc: true,
    range: true,
  }) as AST;
}

// è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºæ¨¡æ‹Ÿä¸Šä¸‹æ–‡
function createContext() {
  const errors: any[] = [];
  const sourceCode = new Map<string, string>();

  return {
    errors,
    context: {
      report: (data: any) => errors.push(data),
      getSourceCode: () => sourceCode.get("code") || "",
      options: [] as string[],
    },
    setSourceCode: (code: string) => sourceCode.set("code", code),
  };
}
```

è§„åˆ™æµ‹è¯•ä»£ç ï¼š

```typescript
describe("Semiè§„åˆ™æµ‹è¯•", () => {
  it("åº”è¯¥æ£€æµ‹å‡ºç¼ºå°‘åˆ†å·çš„æƒ…å†µ (alwaysæ¨¡å¼)", () => {
    // å‡†å¤‡æµ‹è¯•ä»£ç å’Œä¸Šä¸‹æ–‡
    const code = "const a = 1\nconst b = 2;";
    const { context, errors, setSourceCode } = createContext();
    setSourceCode(code);
    context.options = ["always"];

    // åˆ›å»ºè§„åˆ™ç›‘å¬å™¨å¹¶åº”ç”¨åˆ°AST
    const listener = Semi.create(context);
    const ast = parseCode(code);
    traverse(ast, listener);

    // éªŒè¯ç»“æœ
    expect(errors.length).toBe(1);
    expect(errors[0].message).toContain("Missing semicolon");
    expect(errors[0].ruleId).toBe("semi");
  });

  it("ä¸åº”è¯¥æ£€æµ‹ç¼ºå°‘åˆ†å·çš„æƒ…å†µ (alwaysæ¨¡å¼)", () => {
    // å‡†å¤‡æµ‹è¯•ä»£ç å’Œä¸Šä¸‹æ–‡ - æ‰€æœ‰è¯­å¥éƒ½æœ‰åˆ†å·
    const code = "const a = 1;\nconst b = 2;";
    const { context, errors, setSourceCode } = createContext();
    setSourceCode(code);
    context.options = ["always"];

    // åˆ›å»ºè§„åˆ™ç›‘å¬å™¨å¹¶åº”ç”¨åˆ°AST
    const listener = Semi.create(context);
    const ast = parseCode(code);
    traverse(ast, listener);

    // éªŒè¯ç»“æœ - ä¸åº”è¯¥æœ‰é”™è¯¯
    expect(errors.length).toBe(0);
  });

  it("åº”è¯¥æ£€æµ‹å‡ºå¤šä½™åˆ†å·çš„æƒ…å†µ (neveræ¨¡å¼)", () => {
    // å‡†å¤‡æµ‹è¯•ä»£ç å’Œä¸Šä¸‹æ–‡
    const code = "const a = 1;\nconst b = 2";
    const { context, errors, setSourceCode } = createContext();
    setSourceCode(code);
    context.options = ["never"];

    // åˆ›å»ºè§„åˆ™ç›‘å¬å™¨å¹¶åº”ç”¨åˆ°AST
    const listener = Semi.create(context);
    const ast = parseCode(code);
    traverse(ast, listener);

    // éªŒè¯ç»“æœ
    expect(errors.length).toBe(1);
    expect(errors[0].message).toContain("Extra semicolon");
    expect(errors[0].ruleId).toBe("semi");
  });

  it("ä¸åº”è¯¥æ£€æµ‹å¤šä½™åˆ†å·çš„æƒ…å†µ (neveræ¨¡å¼)", () => {
    // å‡†å¤‡æµ‹è¯•ä»£ç å’Œä¸Šä¸‹æ–‡ - æ‰€æœ‰è¯­å¥éƒ½æ²¡æœ‰åˆ†å·
    const code = "const a = 1\nconst b = 2";
    const { context, errors, setSourceCode } = createContext();
    setSourceCode(code);
    context.options = ["never"];

    // åˆ›å»ºè§„åˆ™ç›‘å¬å™¨å¹¶åº”ç”¨åˆ°AST
    const listener = Semi.create(context);
    const ast = parseCode(code);
    traverse(ast, listener);

    // éªŒè¯ç»“æœ - ä¸åº”è¯¥æœ‰é”™è¯¯
    expect(errors.length).toBe(0);
  });
});
```

## 4. æœ€å

### é¡¹ç›®æ€»ç»“

é€šè¿‡æœ¬æ–‡çš„å­¦ä¹ ï¼Œæˆ‘ä»¬ä»é›¶å¼€å§‹å®ç°äº†ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„ Mini-ESLint ä»£ç æ£€æŸ¥å·¥å…·ã€‚è¿™ä¸ªé¡¹ç›®ä¸ä»…å¸®åŠ©æˆ‘ä»¬æ·±å…¥ç†è§£äº† ESLint çš„å·¥ä½œåŸç†ï¼Œæ›´é‡è¦çš„æ˜¯è®©æˆ‘ä»¬æŒæ¡äº†ä»¥ä¸‹æ ¸å¿ƒæŠ€èƒ½ï¼š

- **AST æŠ½è±¡è¯­æ³•æ ‘çš„è§£æä¸éå†**ï¼šç†è§£ä»£ç å¦‚ä½•è¢«ç»“æ„åŒ–è¡¨ç¤ºå’Œåˆ†æ
- **è§„åˆ™ç³»ç»Ÿçš„è®¾è®¡ä¸å®ç°**ï¼šå­¦ä¼šå¦‚ä½•æ„å»ºå¯æ‰©å±•çš„æ’ä»¶åŒ–æ¶æ„
- **CLI å·¥å…·å¼€å‘**ï¼šäº†è§£å¦‚ä½•æ„å»ºç”¨æˆ·å‹å¥½çš„å‘½ä»¤è¡Œå·¥å…·
- **TypeScript å·¥ç¨‹å®è·µ**ï¼šä½“éªŒç±»å‹å®‰å…¨çš„å¼€å‘æµç¨‹

### é¡¹ç›®ä»“åº“

ğŸ”— **GitHub ä»“åº“åœ°å€**ï¼š[https://github.com/lzj2000/mini-eslint/tree/master](https://github.com/lzj2000/mini-eslint/tree/master)

### åç»­åŠŸèƒ½è§„åˆ’

ç›®å‰ Mini-ESLint åªå…·å¤‡äº†åŸºæœ¬çš„ä»£ç æ£€æŸ¥åŠŸèƒ½ï¼Œè¿˜æœ‰å¾ˆå¤šå¾…å®Œå–„çš„åŠŸèƒ½ï¼ŒåŒ…æ‹¬æ›´å¤šçš„è§„åˆ™ã€è‡ªåŠ¨ä¿®å¤ã€æ’ä»¶ã€å¿½ç•¥æ–‡ä»¶ã€å¹¶è¡Œä¼˜åŒ–ç­‰ç­‰ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥å°è¯•å®ç°ã€‚
